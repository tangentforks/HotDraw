<?xml version="1.0"?><st-source><!-- Name: HotDraw Animated ExamplesNotice: Copyright 1993 - 2013 John BrantThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: psql_public_cst_2007DbTrace: 87403DbUsername: niallrDbVersion: 1.8DevelopmentPrerequisites: #(#(#any 'HotDraw Animation Framework' ''))PackageName: HotDraw Animated ExamplesParcel: #('HotDraw Animated Examples')ParcelName: HotDraw Animated ExamplesPrerequisiteParcels: #(#('HotDraw Animation Framework' ''))PrintStringCache: (1.8,niallr)Version: 1.8Post-Load Block: 	[:parcel | Refactory.HotDraw.MovingDrawingEditor postLoadActionFor: parcel]Date: 3:02:52 PM April 5, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.4) of 22 March 2013 on 5 April 2013 at 15:02:52</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ObjectWorldDrawing</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.AnimatedDrawing</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-ObjectWorld</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.ObjectWorldDrawing</class-id><body>I am  a Drawing (from HotDraw) that provides a number of instance methods for ObjectWorld animation control.</body></comment><class><name>ObjectWorldFigureModel</name><environment>Refactory.HotDraw</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure name animationMethods model pause stayVisible </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-ObjectWorld</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id><body>a MetaFigure for the ObjectWorld application.=========================Assumes that a figure must implement :	rotateBy:     Rotate the figure by the given angle.Instance Variables:name &lt;String&gt;    The name of the figure in the ObjectWorld.  This is the string associated with the figure by the user.animationMethods  &lt;Collection&gt;    A collection of the method the figure should apply to itself to perform a step in its animation.model &lt;ObjectParser&gt;   The ObjectWorld that the figure belongs to.pause &lt;Boolean&gt;   Indicator for the figure as to whether or not it will perform its animation step.  This allows each figure to control whether or not it wants to perform a step in its   animation.stayVisible &lt;Boolean&gt;   Indicator telling the figure if it should stay within the visible bounds given to it as part of an animation step.  Class Variables:DebugFlag &lt;Boolean&gt;   Indicator telling the figure to perform debug operations.DefaultGrow &lt;Integer&gt;   Amount to grow a figure when the grow or shrink message is sent to a figure.  DefaultRotate &lt;Float&gt;   Angle to rotate a figure when the turnRight or turnLeft message is sent to a figure.DefaultMovement &lt;Integer&gt;   Amount to move a figure when it is sent the moveLeft, moveRight, moveUp, or moveDown messages are sent to it.DefaultOrbit &lt;Float&gt;   Angle to rotate the figure around the object it is orbiting.DefaultSize &lt;Integer&gt;   Size in pixels to create the initial figure.</body></comment><class><name>NetworkEditor</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.DrawingEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes edgeWeights nodeList2 nodeList1 textEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Network Drawing</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.NetworkEditor</class-id><body>Network editors are a good example of embedding HotDraw in a largerMVC application, and of how to do animation in HotDraw.  The ideais that you create a set of nodes and can assign weights to the edgesbetween the nodes.  An edge with weight zero doesn''t exist.  Thedrawing rearranges itself so that edges act like springs, and nodeswith high-weight edges are closer together than nodes with low-weightedges.  nodes   &lt;Collection of: NetworkNode&gt;edgeWeights &lt;Dictionary from: Figure to: Number&gt;node1, node2 &lt;NetworkNode&gt;  the selected nodesNetworkEditor open</body></comment><class><name>WorkspaceCompiler</name><environment>Refactory.HotDraw</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workspaceDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-ObjectWorld</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.WorkspaceCompiler</class-id><body>I am a compiler for an object that is a workspace, i.e. it has its ownset of variables that can be named by the code I evaluate.  You shouldonly use me to evaluate strings using my public access protocol.  Myinherited public access protocol has not been tested and probablydoes not work.</body></comment><class><name>ObjectWorld</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.DrawingEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser commandText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-ObjectWorld</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.ObjectWorld</class-id><body>I am the model in an ObjectWorld application.  I am like a subclass of both ValueHolder and DrawingEditor, because one of my views is a ComposedTextView and the other one is a DrawingView.  However, I copy code from DrawingEditor and am a subclass of ValueHolder.In ObejctWorld, if a user types ''self doSomething'' the message gets sent to me.  Things users are allowed to do are all contained in my ''public'' protocol.  Special commands are trapped in the ''private'' protocol (i.e. ''self remove'' which does *not* remove ObjectWorld).ObjectParser and ObjectWorldMetaFigure are the other important classes of the ObjectWorld application.  ObjectParser is the controller of the text pane, and it parses user input and directs messages to the ObjectWorld, to the drawing, and to the individual figures in the drawing.  ObjectWorldMetaFigure implements ObjectWorld-specific protocol for figures.  Instance variables:parser :-	The object parsing ObjectWorld commands is also the controller of our text pane.drawingView	The view of our drawing, needed for flashing, etc.drawing	The ObjectWorldDrawing. tools, currentTool, fileName:	variables from DrawingEditor</body></comment><class><name>MovingDrawingEditor</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.DrawingEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Moving Drawing</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.MovingDrawingEditor</class-id><body>A MovingDrawing is one of the simplest examples of how to do animation.It simulates objects in orbit around each other, i.e. the n-bodyproblem.MovingDrawingEditor open</body></comment><class><name>ObjectParser</name><environment>Refactory.HotDraw</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings drawingEditor </inst-vars><class-inst-vars></class-inst-vars><imports>			private TextConstants.*			</imports><category>HotDraw-ObjectWorld</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.ObjectParser</class-id><body>This is the parser and controller for the StringHolder part of ObjectWorld.   Hacks have been added to ''access'' and doItProcessing to allow user''s to enter text such as ''fred moveRight!!'' and have the ''!!'' cause a doIt.Instance Variablesbindings :-	A dictionary of all of the named objects that we currently know about.  This dictionary always contains a binding to map ''self'' to our model (i.e. an ObjectWorld object)</body></comment><class><name>NetworkDrawing</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.AnimatedDrawing</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes edgeWeights forces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Network Drawing</category><attributes><package>HotDraw Animated Examples</package></attributes></class><class><name>MovingFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.RectangleFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>velocity </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Moving Drawing</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.MovingFigure</class-id><body>A RectangleFigure with a velocity.The only instance variable, velocity, is a point that represents thevelocity vector.</body></comment><class><name>MovingDrawing</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.AnimatedDrawing</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Moving Drawing</category><attributes><package>HotDraw Animated Examples</package></attributes></class><comment><class-id>Refactory.HotDraw.MovingDrawing</class-id><body>MovingDrawing is a simple drawing that shows animation.</body></comment><class><name>NetworkNode</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.CachedFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Network Drawing</category><attributes><package>HotDraw Animated Examples</package></attributes></class><shared-variable><name>DebugFlag</name><environment>Refactory.HotDraw.ObjectWorldFigureModel</environment><private>true</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>HotDraw Animated Examples</package></attributes></shared-variable><shared-variable><name>DefaultOrbit</name><environment>Refactory.HotDraw.ObjectWorldFigureModel</environment><private>true</private><constant>false</constant><category>As yet unclassified</category><initializer>0.0872665</initializer><attributes><package>HotDraw Animated Examples</package></attributes></shared-variable><shared-variable><name>DefaultMovement</name><environment>Refactory.HotDraw.ObjectWorldFigureModel</environment><private>true</private><constant>false</constant><category>As yet unclassified</category><initializer>10</initializer><attributes><package>HotDraw Animated Examples</package></attributes></shared-variable><methods><class-id>Refactory.HotDraw.ObjectWorldDrawing</class-id> <category>animating</category><body package="HotDraw Animated Examples">pause	"Pause the animation on all Figures in the receiving Drawing."	self components do: [:each | each model notNil ifTrue: [each model pause]]</body><body package="HotDraw Animated Examples">resume	"Resume animation on all Figures in the receiving Drawing. 	(This is the opposite of pause.)"	self components 		do: [:each | each model notNil ifTrue: [each model resume]]</body><body package="HotDraw Animated Examples">step	"Tell each Figure in the receiving Drawing to perform 	one step in its animation sequence (if any)."	self components 		do: [:each | each model notNil ifTrue: [each model stepIn: self bounds]]</body><body package="HotDraw Animated Examples">stopAll	"Shut off animation and delete the list of animation steps for	all Figures in the receiving Drawing."	self components do: [:each | each model notNil ifTrue: [each model stop]]</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldDrawing</class-id> <category>adding</category><body package="HotDraw Animated Examples">add: aFigure 	ObjectWorldFigureModel on: aFigure.	aFigure model model: self model.	^super add: aFigure</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>figure</category><body package="HotDraw Animated Examples">bounds	^figure bounds</body><body package="HotDraw Animated Examples">center	^figure center</body><body package="HotDraw Animated Examples">changed	^figure changed</body><body package="HotDraw Animated Examples">damage	^figure damage</body><body package="HotDraw Animated Examples">number	^figure number</body><body package="HotDraw Animated Examples">number: aNumber	^figure number: aNumber</body><body package="HotDraw Animated Examples">translateBy: aPoint	^figure translateBy: aPoint</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>animating</category><body package="HotDraw Animated Examples">animate: aMethod 	"Add aMethod to the list of methods to invoke for animation on this 	figure. aMethod is either a block or the name of a message to send."	| block |	block := aMethod isSymbol 				ifTrue: 					[(self respondsTo: aMethod) 						ifTrue: [[:fig | fig perform: aMethod]]						ifFalse: [^self error: aMethod , ' is an illegal message']]				ifFalse: [aMethod].	animationMethods addFirst: block</body><body package="HotDraw Animated Examples">checkVisible: drawingBounds oldBounds: oldBounds 	| newBox xDirection yDirection |	stayVisible ifFalse: [^self].	newBox := self bounds.	xDirection := newBox left - oldBounds left.	yDirection := newBox top - oldBounds top.	xDirection &lt; 0 &amp; (newBox right &lt; drawingBounds left) 		ifTrue: [self translateBy: (drawingBounds width + newBox width) @ 0].	xDirection &gt; 0 &amp; (newBox left &gt; drawingBounds right) 		ifTrue: [self translateBy: (drawingBounds width + newBox width) negated @ 0].	yDirection &lt; 0 &amp; (newBox bottom &lt; drawingBounds top) 		ifTrue: [self translateBy: 0 @ (drawingBounds height + newBox height)].	yDirection &gt; 0 &amp; (newBox top &gt; drawingBounds bottom) 		ifTrue: [self translateBy: 0 @ (drawingBounds height + newBox height) negated]</body><body package="HotDraw Animated Examples">home	"Tell this Figure to move to the center of the visible part of the view. "	| newCenter bounds |	bounds := model drawing bounds.	newCenter := bounds center - self center.	figure translateBy: newCenter</body><body package="HotDraw Animated Examples">pause	"Suspend animation for this Figure."	pause := true</body><body package="HotDraw Animated Examples">resume	"Begin animation for this Figure."	pause := false</body><body package="HotDraw Animated Examples">stayVisible	"Require that this Figure stay within the visible part of the view."	stayVisible := true</body><body package="HotDraw Animated Examples">stepIn: drawingBounds 	"Perform all the methods in the animation list on this Figure. This is  	meant to move the figure one step through its animation. If the pause 	indicator is set, skip animation for this figure. If animation is to occur, 	then once it has moved through one step, see if the figure is supposed 	to stay within the visible bounds of drawing that were passed in. If so, 	make sure the user can still see the figure, if not, move it to the opposite 	side of the drawing based on the direction the figure is traveling in."	| oldBounds |	oldBounds := self bounds.	pause ifTrue: [^self].	animationMethods do: [:method | method value: self].	self checkVisible: drawingBounds oldBounds: oldBounds</body><body package="HotDraw Animated Examples">stop	"Stop all the methods in the animation list on this Figure. This is an 	   ObjectWorld extension. This method is intended to be invoked  	 by the ObjectWorld user."	[animationMethods isEmpty] whileFalse: [animationMethods removeFirst]</body><body package="HotDraw Animated Examples">stop: aMethod 	"Stop the given method from the animation list for the figure. 	   This is an ObjectWorld extension. This method is intended to be invoked  	 by the ObjectWorld user."	| methodSymbol |	methodSymbol := aMethod asSymbol.	(animationMethods includes: methodSymbol) 		ifTrue: [animationMethods remove: methodSymbol ifAbsent: []]</body><body package="HotDraw Animated Examples">unbounded	stayVisible := false</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>accessing</category><body package="HotDraw Animated Examples">menu	| mb |	mb := MenuBuilder new.	mb add: 'Rename...' -&gt; #rename.	^mb menu</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>transforming</category><body package="HotDraw Animated Examples">moveDown	"Move the receiving Figure downwards the default distance."	self moveDown: self class defaultMovement</body><body package="HotDraw Animated Examples">moveDown: anInteger 	"Move the receiving Figure downwards the specified distance.	Intended for the ObjectWorld user."	self translateBy: 0 @ anInteger</body><body package="HotDraw Animated Examples">moveLeft	"Move the receiving Figure left the default distance.	Intended for the ObjectWorld user."	self moveLeft: self class defaultMovement</body><body package="HotDraw Animated Examples">moveLeft: anInteger 	"Move the receiving Figure left the specified distance.	Intended for the ObjectWorld user."	self translateBy: anInteger negated @ 0</body><body package="HotDraw Animated Examples">moveRight	"Move the receiving Figure right the default distance.	Intended for the ObjectWorld user."	self moveRight: self class defaultMovement</body><body package="HotDraw Animated Examples">moveRight: anInteger 	"Move the receiving Figure right the specified distance.	Intended for the ObjectWorld user."	self translateBy: anInteger @ 0</body><body package="HotDraw Animated Examples">moveUp	"Move the receiving Figure upwards the default distance. 	Intended for the ObjectWorld user."	self moveUp: self class defaultMovement</body><body package="HotDraw Animated Examples">moveUp: anInteger 	"Move the receiving Figure upwards the specified distance. 	Intended for the ObjectWorld user."	self translateBy: 0 @ anInteger negated</body><body package="HotDraw Animated Examples">orbit: aFigure 	"Make the receiving Figure move in an 'orbit' around aFigure. 	To do this, we rotate the receiver about the center of aFigure.	This is an ObjectWorld user method."	| deltaX deltaY sin cos newX newY |	deltaX := (self center x - aFigure center x) asDouble.	deltaY := (self center y - aFigure center y) asDouble.	sin := self class defaultOrbit sin.	cos := self class defaultOrbit cos.	newX := aFigure center x + (deltaX * cos) - (deltaY * sin) - self center x.	newY := aFigure center y + (deltaY * cos) + (deltaX * sin) - self center y.	figure translateBy: newX @ newY</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>private</category><body package="HotDraw Animated Examples">doesNotUnderstand: aMessage 	"Override the same method in the Object class to allow us to	signal the user that they made an error by flashing the view,	rather than by raising an exception and popping up a window."	self class debugFlag 		ifTrue: [^super doesNotUnderstand: aMessage]		ifFalse: [model parser view flash]</body><body package="HotDraw Animated Examples">rename	"Let the ObjectWorld user change the name of the receiver with a dialogue."	| newname defaultName |	defaultName := name isNil ifTrue: [''] ifFalse: [name].	newname := Dialog request: 'Enter name of object:'				initialAnswer: defaultName.	self name: newname</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>initialize-release</category><body package="HotDraw Animated Examples">figure	^figure</body><body package="HotDraw Animated Examples">figure: aFigure	figure := aFigure</body><body package="HotDraw Animated Examples">initialize	"Create the animation list, start the figure out with pausing turned off	   and let it roam outside the visible part of the drawing. "	animationMethods := OrderedCollection new.	pause := false.	stayVisible := false</body><body package="HotDraw Animated Examples">model: aModel	model := aModel</body><body package="HotDraw Animated Examples">name	"Return the name of the figure."	^name</body><body package="HotDraw Animated Examples">name: aString 	"Register the receiver with the local model. Check if the receiver has been registered 	before (i.e. if the receiver already has a non-null name), in which case the receiver 	must unregister itself before re-registering under the new name."	name isNil ifFalse: [model unregister: self].	model register: self as: aString.	name := aString</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel</class-id> <category>removing</category><body package="HotDraw Animated Examples">remove	"Remove the receiving Figure from its Drawing."	figure changed.	self unregister.	model drawing remove: self</body><body package="HotDraw Animated Examples">unregister	"Remove the receiving Figure from its Drawing."	model unregister: self</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel class</class-id> <category>accessing</category><body package="HotDraw Animated Examples">debugFlag	^DebugFlag</body><body package="HotDraw Animated Examples">debugFlag: aBoolean 	"Control the class' DebugFlag: if true, then handle doesNotUnderstand 	messages in the usual way, i.e. raise an exception. If false (the default), 	then override doesNotUnderstand: to just flash the view to signal the 	error to the user."	DebugFlag := aBoolean</body><body package="HotDraw Animated Examples">defaultMovement	"Return the default amount of movement for a figure"	^DefaultMovement</body><body package="HotDraw Animated Examples">defaultMovement: anInteger 	"Set the default amount of movement for a figure to anInteger"	DefaultMovement := anInteger</body><body package="HotDraw Animated Examples">defaultOrbit	^DefaultOrbit</body><body package="HotDraw Animated Examples">defaultOrbit: aFloat 	DefaultOrbit := aFloat</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorldFigureModel class</class-id> <category>instance creation</category><body package="HotDraw Animated Examples">new	^super new initialize</body><body package="HotDraw Animated Examples">on: aFigure 	| model |	model := self new.	model figure: aFigure.	aFigure model: model</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>weights</category><body package="HotDraw Animated Examples">acceptText: aString from: what	self weight: aString asNumber.	^true</body><body package="HotDraw Animated Examples">node1	^self nodeList1 selection</body><body package="HotDraw Animated Examples">node2	^self nodeList2 selection</body><body package="HotDraw Animated Examples">textMenu	"Answer a Menu for the node list panes."	^Menu			labels: 'again\undo\copy\cut\paste\accept\cancel' withCRs			lines: #(2 5 )			values: #(#again #undo #copySelection #cut #paste #acceptText:from: #cancel )</body><body package="HotDraw Animated Examples">weight	^(edgeWeights at: self node1 ifAbsent: [^0])		at: self node2 ifAbsent: [0]</body><body package="HotDraw Animated Examples">weight: number 	| node1 node2 |	node1 := self node1.	node2 := self node2.	node1 isNil | node2 isNil ifTrue: [^self].	(self getTableFor: node1)		at: node2 put: number.	(self getTableFor: node2)		at: node1 put: number.	drawing		edgeWeight: number		from: node1		to: node2</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>private</category><body package="HotDraw Animated Examples">getTableFor: name 	^edgeWeights at: name ifAbsentPut: [Dictionary new]</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>nodes</category><body package="HotDraw Animated Examples">addNode	"Get name of node from user."	| name |	name := Dialog request: 'enter name of new node'.	name isNil ifTrue: [^nil].	nodes add: name.	drawing addNode: name.	self updateLists</body><body package="HotDraw Animated Examples">deleteNode1	self node1 isNil ifTrue: [^self].	nodes remove: self node1 ifAbsent: [].	drawing removeNode: self node1.	self updateLists</body><body package="HotDraw Animated Examples">deleteNode2	self node2 isNil ifTrue: [^self].	nodes remove: self node2 ifAbsent: [].	drawing removeNode: self node2.	self updateLists</body><body package="HotDraw Animated Examples">nodeMenu1	"Answer a Menu for the node list panes."	^Menu			labels: 'add node\delete node' withCRs			lines: #( )			values: #(#addNode #deleteNode1 )</body><body package="HotDraw Animated Examples">nodeMenu2	"Answer a Menu for the node list panes."	^Menu			labels: 'add node\delete node' withCRs			lines: #( )			values: #(#addNode #deleteNode2 )</body><body package="HotDraw Animated Examples">updateLists	| selection |	selection := self nodeList1 selection.	self nodeList1 list: nodes asList.	self nodeList1 selection: selection.	selection := self nodeList2 selection.	self nodeList2 list: nodes asList.	self nodeList2 selection: selection</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>aspects</category><body package="HotDraw Animated Examples">nodeList1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nodeList1 isNil		ifTrue:			[nodeList1 := SelectionInList new]		ifFalse:			[nodeList1]</body><body package="HotDraw Animated Examples">nodeList2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nodeList2 isNil		ifTrue:			[nodeList2 := SelectionInList new]		ifFalse:			[nodeList2]</body><body package="HotDraw Animated Examples">textEditor	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textEditor isNil		ifTrue:			[textEditor := String new asValue]		ifFalse:			[textEditor]</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>initialize-release</category><body package="HotDraw Animated Examples">initialize	super initialize.	nodes := SortedCollection new.	edgeWeights := Dictionary new.	self updateLists</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>updating</category><body package="HotDraw Animated Examples">changedNode	textEditor value: self weight printString</body><body package="HotDraw Animated Examples">update: anAspectSymbol with: aParameter from: aSender 	anAspectSymbol == #removeNode 		ifTrue: 			[nodes remove: aParameter ifAbsent: [].			edgeWeights removeKey: aParameter ifAbsent: [].			edgeWeights values do: [:value | value removeKey: aParameter ifAbsent: []].			self updateLists].	^super 		update: anAspectSymbol		with: aParameter		from: aSender</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor</class-id> <category>drawing description</category><body package="HotDraw Animated Examples">drawingClass	^NetworkDrawing</body><body package="HotDraw Animated Examples">windowName	^'Network Editor'</body></methods><methods><class-id>Refactory.HotDraw.WorkspaceCompiler</class-id> <category>public access</category><body package="HotDraw Animated Examples">evaluate: textOrStream inWorkspace: aDict receiver: receiver notifying: aRequestor ifFail: failBlock 	"Evaluate an expression binding the receiver to self and using aDict as a global dictionary of names.	The idea is that aDict is a workspace context of some sort, and receiver	might be the workspace."	workspaceDictionary := aDict.	^self 		evaluate: textOrStream		in: nil		receiver: receiver		notifying: aRequestor		ifFail: failBlock</body></methods><methods><class-id>Refactory.HotDraw.WorkspaceCompiler</class-id> <category>private</category><body package="HotDraw Animated Examples">scopeForClass	"Return a scope for the workspace. This is a carefully placed hack."	| scope |	scope := StaticScope variables: workspaceDictionary.	scope outerScope: (NameScope forEnvironment: Smalltalk).	^scope</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>public</category><body package="HotDraw Animated Examples">clearAnimation	"Clear list of figures being animated"	drawing stopAll</body><body package="HotDraw Animated Examples">pause	"Temporarily pause animation"	drawing pause</body><body package="HotDraw Animated Examples">refresh	"If the screen has gotten out of sync refresh it"	drawing repairDamage</body><body package="HotDraw Animated Examples">resume	"Restart animation"	drawing resume</body><body package="HotDraw Animated Examples">setFont: aFontSize 	"set a new font for everything in the Universe"	TextAttributes setDefaultTo: aFontSize asSymbol.	TextAttributes resetViews</body><body package="HotDraw Animated Examples">who	"Show the objects we know about"	| mb |	mb := MenuBuilder new.	parser keys do: [:each | mb add: each -&gt; each].	mb menu startUp</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>ObjectParser protocol</category><body package="HotDraw Animated Examples">register: anObject as: aString	parser register: anObject as: aString</body><body package="HotDraw Animated Examples">unregister: anObject	parser unregister: anObject</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>user interface</category><body package="HotDraw Animated Examples">browse	"Browse only the methods users are allowed to see"	((#{Refactory.Browser.BrowserEnvironment} 		valueOrDo: [^self error: 'No Browser Loaded']) new 		forClass: self class		protocols: #(#public)) openEditor</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>drawing description</category><body package="HotDraw Animated Examples">drawingClass	^ObjectWorldDrawing</body><body package="HotDraw Animated Examples">windowName	^'Object World'</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>aspects</category><body package="HotDraw Animated Examples">commandText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^commandText isNil		ifTrue:			[commandText := String new asValue]		ifFalse:			[commandText]</body><body package="HotDraw Animated Examples">subcanvas	^self</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>accessing</category><body package="HotDraw Animated Examples">parser	^parser</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>private</category><body package="HotDraw Animated Examples">remove	"Catch an attempt by the user to do a 'self remove!!' from the	ObjectWorld text window."	parser view flash</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld</class-id> <category>interface opening</category><body package="HotDraw Animated Examples">postBuildWith: aBuilder 	| editor oldController |	super postBuildWith: aBuilder.	editor := (builder componentAt: #commandText) widget.	oldController := editor controller.	editor controller: (parser := (ObjectParser new)						drawingEditor: self;						keyboardProcessor: oldController keyboardProcessor;						yourself)</body></methods><methods><class-id>Refactory.HotDraw.MovingDrawingEditor</class-id> <category>drawing description</category><body package="HotDraw Animated Examples">drawingClass	^MovingDrawing</body><body package="HotDraw Animated Examples">toolNames	"Return the list of names for the tools."	^#('Selection Tool' 	nil 	'Delete Tool' 	'Bring To Front Tool' 	'Send To Back Tool' 	nil 	'Moving Figure Tool')</body><body package="HotDraw Animated Examples">windowName	^'Moving Drawing'</body></methods><methods><class-id>Refactory.HotDraw.MovingDrawingEditor class</class-id> <category>parcel load/unload/save</category><body package="HotDraw Animated Examples">obsolete	[Tool reinitialize] on: Error do: [:ex | ex return: nil].	super obsolete</body><body package="HotDraw Animated Examples">postLoadActionFor: aParcel	Tool reinitialize</body></methods><methods><class-id>Refactory.HotDraw.MovingDrawingEditor class</class-id> <category>resources</category><body package="HotDraw Animated Examples">movingFigureIcon	^self rectangleIcon</body></methods><methods><class-id>Refactory.HotDraw.ObjectParser</class-id> <category>registration</category><body package="HotDraw Animated Examples">keys	"Return all of the keys we have bindings for"	^bindings keys</body><body package="HotDraw Animated Examples">register: anObject as: aString 	"Register aString as a pointer to anObject"	bindings at: aString asSymbol put: anObject</body><body package="HotDraw Animated Examples">unregister: anObject 	"Remove anObject from the binding list"	bindings removeKey: anObject model name asSymbol</body></methods><methods><class-id>Refactory.HotDraw.ObjectParser</class-id> <category>private</category><body package="HotDraw Animated Examples">browse	drawingEditor browse</body><body package="HotDraw Animated Examples">evaluateSelection	"Evaluate the current text selection as an expression "	| result selectionStart oldTextSize selection |	selectionStart := self selectionStartIndex.	oldTextSize := self text size.	selection := self selection.	result := WorkspaceCompiler new 				evaluate: self selectionAsStream				inWorkspace: bindings				receiver: drawingEditor				notifying: self				ifFail: [].	self selection asString = selection asString 		ifFalse: 			[self selectFrom: selectionStart				to: selectionStart + selection size - 1 + (self text size - oldTextSize)	"Reselect doIt range after compiler interaction"].	"Smalltalk logChange: self selection string."	^result</body><body package="HotDraw Animated Examples">selectAndDoItKey: aKey 	"Select the text that has been typed recently and DoIt"	self selectCurrentTypeInKey: aKey.	self evaluateSelection</body></methods><methods><class-id>Refactory.HotDraw.ObjectParser</class-id> <category>initialize-release</category><body package="HotDraw Animated Examples">drawingEditor: aModel 	bindings at: 'self' put: aModel.	drawingEditor := aModel</body><body package="HotDraw Animated Examples">initialize	| table |	super initialize.	bindings := Dictionary new.	table := self dispatchTable.	table 		bindValue: #selectAndDoItKey:		to: ESC		followedBy: ESC.	dispatchTable := table</body><body package="HotDraw Animated Examples">initializeMenu	menuHolder := (Menu 				labelList: #(#(#again #undo) #(#copy #cut #paste) #(#browse) #('do it' 'print it' 'inspect') #(#accept #cancel) #(#hardcopy))				values: #(#again #undo #copySelection #cut #paste #browse #doIt #printIt #inspectIt #accept #cancel #hardcopy)) 					asValue</body></methods><methods><class-id>Refactory.HotDraw.NetworkDrawing</class-id> <category>deleting</category><body package="HotDraw Animated Examples">remove: aFigure 	| index |	super remove: aFigure.	aFigure class = NetworkNode ifFalse: [^self].	self changed: #removeNode with: aFigure name.	index := self indexOfNode: aFigure name.	nodes removeAtIndex: index.	edgeWeights do: [:each | each removeAtIndex: index]</body></methods><methods><class-id>Refactory.HotDraw.NetworkDrawing</class-id> <category>accessing</category><body package="HotDraw Animated Examples">addNode: aName 	| aNode anOC |	aNode := NetworkNode name: aName.	aNode origin: self center.	nodes add: aNode.	self add: aNode.	edgeWeights do: [:oc | oc add: 0].	anOC := OrderedCollection new: nodes size.	nodes size timesRepeat: [anOC add: 0].	edgeWeights add: anOC.	forces add: 0</body><body package="HotDraw Animated Examples">edgeWeight: aNum from: name1 to: name2 	| i j figure |	i := self indexOfNode: name1.	j := self indexOfNode: name2.	(((edgeWeights at: i) at: j) == 0 and: [aNum ~~ 0]) 		ifTrue: 			["Add an edge in the drawing"			figure := (nodes at: i) 						connectFromPoint: (nodes at: i) center						to: (nodes at: j)						at: (nodes at: j) center.			self add: figure].	aNum == 0 ifTrue: [self error: 'Need code to delete edge'].	(edgeWeights at: i) at: j put: aNum.	^(edgeWeights at: j) at: i put: aNum</body><body package="HotDraw Animated Examples">indexOfNode: name1 	1 to: nodes size do: [:i | (nodes at: i) name = name1 ifTrue: [^i]].	self error: name1 , ' is not a node'</body><body package="HotDraw Animated Examples">removeNode: aName 	| index |	index := self indexOfNode: aName.	self remove: (nodes at: index)</body></methods><methods><class-id>Refactory.HotDraw.NetworkDrawing</class-id> <category>animation</category><body package="HotDraw Animated Examples">step	"Move nodes. Each node repulses others with a force that 	is inverse to their distance. Some nodes have springs, and 	the spring force is constant. Not realistic, but it works."	| center repulsiveConstant stepSize |	nodes isEmpty ifTrue: [^self].	center := self center.	repulsiveConstant := (200000 / nodes size sqrt) truncated.	1 to: forces size do: [:i | forces at: i put: 0 @ 0].	1 to: nodes size		do: 			[:i | 			| n1 sum center1 |			n1 := nodes at: i.			center1 := n1 center.	"Make all nodes attracted to the center of the picture"			sum := forces at: i.			center ~= center1 				ifTrue: [sum := sum + ((center - center1) unitVector * 10)].			i + 1 to: nodes size				do: 					[:j | 					| n2 delta |					n2 := nodes at: j.					delta := center1 - n2 center.					delta = (0 @ 0) 						ifFalse: 							[| spring pairForce distance |							distance := delta x * delta x + (delta y * delta y).							pairForce := delta unitVector * repulsiveConstant / distance.							spring := (edgeWeights at: i) at: j.							spring ~~ 0 								ifTrue: [pairForce := pairForce - (delta unitVector * spring) truncated].							sum := sum + pairForce.							forces at: j put: (forces at: j) - pairForce]].			forces at: i put: sum].	stepSize := forces inject: 0				into: [:max :elem | (elem x abs max: elem y abs) max: max].	stepSize &lt; 1 ifTrue: [^self].	nodes with: forces do: [:node :force | node translateBy: force / 10]</body></methods><methods><class-id>Refactory.HotDraw.NetworkDrawing</class-id> <category>initialize-release</category><body package="HotDraw Animated Examples">initialize	super initialize.	nodes := OrderedCollection new.	forces := OrderedCollection new.	edgeWeights := OrderedCollection new</body></methods><methods><class-id>Refactory.HotDraw.MovingFigure</class-id> <category>accessing</category><body package="HotDraw Animated Examples">force: aPoint	"Apply a force to the object.	The only effect now is to change the velocity."	velocity := velocity + aPoint</body><body package="HotDraw Animated Examples">forceOn: aBody 	| delta x y |	self == aBody ifTrue: [^0 @ 0].	delta := self center - aBody center.	x := delta x = 0 ifTrue: [0] ifFalse: [200 / delta x].	y := delta y = 0 ifTrue: [0] ifFalse: [200 / delta y].	^delta - (x @ y)</body><body package="HotDraw Animated Examples">handles	^TrackHandle allCornersOf: self</body><body package="HotDraw Animated Examples">step	self translateBy: velocity / 100.0.	velocity := 0 @ 0</body></methods><methods><class-id>Refactory.HotDraw.MovingFigure</class-id> <category>initialize-release</category><body package="HotDraw Animated Examples">initialize	"The figure is initially at rest."	super initialize.	velocity := 0 @ 0</body></methods><methods><class-id>Refactory.HotDraw.MovingDrawing</class-id> <category>animation</category><body package="HotDraw Animated Examples">step	"First, calculate the new velocities of each figure by calculating the gravitational	force that each has on the others."	self components do: 			[:fig1 | 			fig1 force: (self components inject: 0 @ 0						into: [:sum :fig2 | sum + (fig2 forceOn: fig1)])].	self components do: [:fig1 | fig1 step]</body></methods><methods><class-id>Refactory.HotDraw.NetworkNode</class-id> <category>displaying</category><body package="HotDraw Animated Examples">fillCache	| title aGC rect |	title := name asComposedText.	cache := Pixmap extent: title extent + (2 @ 4).	aGC := cache graphicsContext.	aGC medium background: LookPreferences defaultForWindows backgroundColor.	aGC paint: ColorValue white.	rect := 0 @ 0 extent: cache extent - (2 @ 2).	aGC displayRectangle: rect.	aGC paint: ColorValue black.	title displayOn: aGC at: 0 @ 2.	aGC displayRectangularBorder: rect.	^cache asImage</body></methods><methods><class-id>Refactory.HotDraw.NetworkNode</class-id> <category>printing</category><body package="HotDraw Animated Examples">printOn: aStream 	aStream		nextPutAll: name;		nextPutAll: ' at: ';		print: self origin</body></methods><methods><class-id>Refactory.HotDraw.NetworkNode</class-id> <category>initialize-release</category><body package="HotDraw Animated Examples">name: aName 	name := aName.	self initialize</body></methods><methods><class-id>Refactory.HotDraw.NetworkNode</class-id> <category>connection</category><body package="HotDraw Animated Examples">connectionFigureClass	^PolylineFigure</body></methods><methods><class-id>Refactory.HotDraw.NetworkNode</class-id> <category>accessing</category><body package="HotDraw Animated Examples">name	^name</body></methods><methods><class-id>Refactory.HotDraw.NetworkNode class</class-id> <category>instance creation</category><body package="HotDraw Animated Examples">name: aName	^self new name: aName</body></methods><methods><class-id>Refactory.HotDraw.Tool class</class-id> <category>tool states</category><body package="HotDraw Animated Examples">initializeMovingFigureTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Moving Figure Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #class put: MovingFigure.tool cursor: Cursor origin]' runs: (RunArray runs: #(84) values: #(nil))); instVarAt: 4 put: (Point x: 202 y: 60); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Create Origin/Corner Figure'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 182 y: 172); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Moving Figure Tool'); to: (stateTable at: 'Create Origin/Corner Figure'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 261 y: 91); add: (Point x: 264 y: 172); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Moving Figure Tool' put: (ToolState name: 'Moving Figure Tool' command: [:tool :event | tool valueAt: #class put: MovingFigure.tool cursor: Cursor origin]).	(Tool stateFor: 'Moving Figure Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Create Origin/Corner Figure'); yourself).</body></methods><methods><class-id>Refactory.HotDraw.NetworkEditor class</class-id> <category>interface specs</category><body package="HotDraw Animated Examples">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Network' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 982 707 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -2 0.65 ) 					#name: #drawing 					#flags: 0 					#component: #drawing ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.65 0 0.333333 0 1 ) 					#name: #nodeList1 					#model: #nodeList1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedNode ) 					#menu: #nodeMenu1 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.333333 2 0.65 0 0.666666 0 1 ) 					#name: #nodeList2 					#model: #nodeList2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedNode ) 					#menu: #nodeMenu2 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.666666 2 0.65 0 1 0 1 ) 					#name: #textEditor 					#model: #textEditor 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.65 0 1 2 0.65 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'drawing' 					#belowWidgets: 'nodeList1 nodeList2 textEditor' ) ) ) )</body></methods><methods><class-id>Refactory.HotDraw.ObjectWorld class</class-id> <category>interface specs</category><body package="HotDraw Animated Examples">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Object World' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 557 381 1044 820 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.3 ) 					#name: #commandText 					#model: #commandText 					#tabRequiresControl: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 28 0.3 0 1 0 1 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#component: #drawing ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.3 0 1 28 0.3 ) 					#flags: 0 					#component: #toolbar ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="HotDraw Animated Examples">toolsHotDrawMovingDrawingEditor	&lt;menuItem: 'Moving Drawing Editor'		nameKey: nil		menu: #(#menuBar #tools #HotDraw)		position: 10.04&gt;	(#{Refactory.HotDraw.MovingDrawingEditor} valueOrDo: [^self]) open</body><body package="HotDraw Animated Examples">toolsHotDrawNetworkEditor	&lt;menuItem: 'Network Editor'		nameKey: nil		menu: #(#menuBar #tools #HotDraw)		position: 10.05&gt;	(#{Refactory.HotDraw.NetworkEditor} valueOrDo: [^self]) open</body><body package="HotDraw Animated Examples">toolsHotDrawObjectWorldEditor	&lt;menuItem: 'ObjectWorld'		nameKey: nil		menu: #(#menuBar #tools #HotDraw)		position: 10.06&gt;	(#{Refactory.HotDraw.ObjectWorld} valueOrDo: [^self]) open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>CachedFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars nextUndoBlock currentUndo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>DrawingEditor</name><environment>Refactory.HotDraw</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttons drawing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><class><name>RectangleFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>AnimatedDrawing</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Drawing</super><private>false</private><indexed-type>none</indexed-type><inst-vars>animationProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Animation</category><attributes><package>HotDraw Animation Framework</package></attributes></class></st-source>