<?xml version="1.0"?><st-source><!-- Name: HotDraw FrameworkNotice: Copyright 1993 - 2013 John BrantThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: NAME				HotDrawAUTHOR			brant@cs.uiuc.eduFUNCTION			Framework for stuctured drawing editorsKEYWORDS			widget graphicsST-VERSIONS		VisualWorksPREREQUISITESTHEN FILE INCONFLICTS WITHDISTRIBUTION		worldSUMMARYThis set of parcels contains HotDraw, a framework for structured, 2D drawing editors. It can/has been used to create many different editors from case tools to object inspectors.  Open using the Launcher's Tools->HotDraw submenu.More information on HotDraw can be found on the HotDraw home page        http://st-www.cs.uiuc.edu/users/brant/HotDraw/HotDraw.htmlGeneral questions about HotDraw can be directed to the HotDraw  mailing list hotdraw@cs.uiuc.edu.	John Brant - 15-Sep-2001	Link updated by Alan Knight, 7-Oct-2005	Updated for VisualWorks 7.8 by Niall Ross and Travis Griggs, 3-Feb-2011DbIdentifier: psql_public_cst_2007DbTrace: 88187DbUsername: niallrDbVersion: 7.10.1 - 2DevelopmentPrerequisites: #(#(#any 'Refactory-Namespace' ''))PackageName: HotDraw FrameworkParcel: #('HotDraw Framework')ParcelName: HotDraw FrameworkPrerequisiteParcels: #(#('Refactory-Namespace' ''))PrintStringCache: (7.10.1 - 2,niallr)Version: 7.10.1 - 2WarningSuppressionBlock: [:prerequisiteName|'BOSS' = prerequisiteName]Post-Load Block: 	[:pkg| Refactory.HotDraw.Drawing postLoadActionFor: pkg ]Warning Suppression Block: 	[:prerequisiteName|'BOSS' = prerequisiteName]Date: 6:21:40 AM December 26, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10.1 (oct13.1) of October 3, 2013 on December 26, 2013 at 6:21:40 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>HotDraw</name><environment>Refactory</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></name-space><class><name>Figure</name><environment>Refactory.HotDraw</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents state attributes model bounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><class><name>CompositeFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.CompositeFigure</class-id><body>CompositeFigure is a Figure that groups other figures into a single figure (composite pattern).Instance Variables:	components	&lt;SequenceableCollection of: Figure&gt;	the figures I'm grouping</body></comment><class><name>ToolbarController</name><environment>Refactory.HotDraw</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pressing pressingItem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Toolbar</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ToolbarController</class-id><body>ToolbarController is the controller for the ToolbarView.Instance Variables:	pressing	&lt;Boolean&gt;	are we pressing a button?	pressingItem	&lt;ButtonDescription | nil&gt;	the items we're pressing</body></comment><class><name>BoundaryConstraint</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>line isStart filledFigure isUpdating </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Constraints</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.BoundaryConstraint</class-id><body>BoundaryConstraint represents a constraint that is placed between a filled figure and a line figure. It computes the lines position so that it is attached to the edge of the filled figure. This constraint only works if the filled figure answers true when sent the containsPoint: message with the filled figures center.Instance Variables:	filledFigure	&lt;Figure&gt;	the filled figure that answers true to "filledFigure containsPoint: filledFigure center"	isStart	&lt;Boolean&gt;	setting the start or stop point of the line	isUpdating	&lt;Boolean&gt;	are we currently setting the lines values (avoids infinite recursion)	line	&lt;PolylineFigure&gt;	the line that is attached</body></comment><class><name>Handle</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner toolState </inst-vars><class-inst-vars>image </class-inst-vars><imports></imports><category>HotDraw-Handles</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.Handle</class-id><body>Handle is a special figure that is displayed when another figure in the drawing is selected. Handles aren't permant figures, but are added and removed whenever another figure is selected/deselected. They are useful for defining special manipulation actions such as resizing, connecting figures, etc.Instance Variables:	owner	&lt;Figure&gt;	the figure that we are for	toolState	&lt;EndToolState&gt;	whenever the tool presses us, goto this state</body></comment><class><name>TrackHandle</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Handle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>moveBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Handles</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.TrackHandle</class-id><body>TrackHandle is a handle that executes a block whenever the cursor is moved. When the mouse button is release, it quits its action.Instance Variables:	moveBlock	&lt;BlockClosure&gt;	a block that is executed for each mouse position, it takes one argument (a Point object)</body></comment><class><name>ButtonDescription</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icon enabled value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Toolbar</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ButtonDescription</class-id><body>ButtonDescription represents a button in the Toolbar. It contains both the icon that is displayed as well as its value.Instance Variables:	enabled	&lt;Boolean&gt;	are we enabled, disabled buttons can be greyed out	icon	&lt;Image&gt;	our image to display	value	&lt;Object&gt;	some data that we represent (can be anything, it isn't interpreted by us)</body></comment><class><name>CachedFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.CachedFigure</class-id><body>CachedFigure is a figure that holds a pixmap of its display. It can be used for complicated figures to cache their display so that they display faster. However, as graphics cards become faster, this figure is less useful.Subclasses must implement the following messages:	private		fillCache	returns a pixmap of our contentsInstance Variables:	cache	&lt;Pixmap&gt;	what we display when we are drawn</body></comment><class><name>IndexedTrackHandle</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.TrackHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Handles</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.IndexedTrackHandle</class-id><body>IndexedTrackHandle is a TrackHandle that has a menu. This menu allows the user to remove points from the line that the handle is for.Instance Variables:	index	&lt;Integer&gt;	the index of the point on the line that we're connected to</body></comment><class><name>TransitionTable</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.TransitionTable</class-id><body>TransitionTable is an abstract class that represents a transition between two states. When sent the nextStateForTool:event: message, it returns the next state for that type of event. If there isn't a next state for that event, it returns nil.Subclasses must implement the following messages:	accessing		goto:	a default constructer method that makes it easier to create the transition tables independently		nextStateForTool:event:	returns the next state for the event or nil if there isn't a next state for that event</body></comment><class><name>SimpleTransitionTable</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.TransitionTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.SimpleTransitionTable</class-id><body>SimpleTransitionTable is a transition table that always goes to another state no matter what the event is.Instance Variables:	nextState	&lt;EndToolState&gt;	the next state to goto</body></comment><class><name>EllipseFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.EllipseFigure</class-id><body>EllipseFigure is a figure that represents ellipses.</body></comment><class><name>ToolbarView</name><environment>Refactory.HotDraw</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>horizontal over selecting </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Toolbar</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ToolbarView</class-id><body>ToolbarView is the view that displays the toolbar.Instance Variables:	horizontal	&lt;Boolean&gt;	description of horizontal	over	&lt;ButtonDescription&gt;	the item the mouse cursor is over	selecting	&lt;ButtonDescription&gt;	the item we're tentatively selecting</body></comment><class><name>RectangleFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.RectangleFigure</class-id><body>RectangleFigure is a figure that displays a rectangle.</body></comment><class><name>TextFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>paragraph selection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.TextFigure</class-id><body>TextFigure is a Figure that represents text.Instance Variables:	paragraph	&lt;Paragraph&gt;	the text that is displayed	selection	&lt;Interval | nil&gt;	the selected text interval, when the figure is part of the drawing's selection, then this selection is also highlightedClass Variables:	InsertionPoint	&lt;Image&gt;	an image of the ^ that is displayed at the insertion point.</body></comment><class><name>EndToolState</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.EndToolState</class-id><body>EndToolState is a state for tools. When this state is entered, the tool evaluates its command, and then returns to the initial state of the tool.EndToolState is also the superclass of ToolState. While it might be better to have an abstract class that is the superclass for both these classes. The abstract class and EndToolState would be essentially the same. The only difference would be that EndToolState would have its isEndState return true.Instance Variables:	command	&lt;BlockClosure&gt;	the command that is executed when we are entered, it takes two arguments, the tool and the event	name	&lt;String&gt;	our state name</body></comment><class><name>RoundedRectangleFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.RectangleFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.RoundedRectangleFigure</class-id><body>RoundedRectangleFigure is a rectangle that has rounded corners.Instance Variables:	inset	&lt;Point&gt;	the offset for the ellipse that draws the rounded corners (if greater than our extent // 2, then we are an ellipse)</body></comment><class><name>PositionConstraint</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver position message isUpdating </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Constraints</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.PositionConstraint</class-id><body>PositionConstraint represents a constraint between a position (a message send) and a message (symbol) of a receiver (figure). Whenever either figure changes, the constraint is re-evaluated, and the receiver is moved to the position.Instance Variables:	isUpdating	&lt;Boolean&gt;	are we currently updating the figure (avoid infinite recursion)	message	&lt;Symbol&gt;	the symbol that is performed on receiver to set its position	position	&lt;MessageSend&gt;	a message send that when evaluated, returns the new position for receiver	receiver	&lt;Figure&gt;	the figure to be constrained</body></comment><class><name>ViewAdapterFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id><body>ViewAdapterFigure adapts VisualCompoents to the Figure protocol, allowing any VisualComponent to be inserted into a Drawing.Instance Variables:	component	&lt;VisualComponent&gt;	the visual component that is adapted</body></comment><class><name>DrawingController</name><environment>Refactory.HotDraw</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.DrawingController</class-id><body>DrawingController is a Controller for a Drawing view.Instance Variables:	keyboardProcessor	&lt;KeyboardProcessor&gt;	the keyboard processor for our window	tool	&lt;Tool&gt;	the current tool selected</body></comment><class><name>FigureTransitionTable</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.TransitionTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figureLookupStates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.FigureTransitionTable</class-id><body>FigureTransitionTable is a transition table for mouse events. It checks what type of figure the mouse is over and then decides what is the next state.Instance Variables:	figureLookupStates	&lt;Dictionary key: Figure class value: EndToolState&gt;	our table, if the figure's class is in the table, then we take it entry, otherwise we lookup its superclass</body></comment><class><name>LineAnnotation</name><environment>Refactory.HotDraw</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>positionSymbol directionSymbol isFilled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.LineAnnotation</class-id><body>LineAnnotation is a visual component that when added to a LineFigure allows you draw special symbols on the end points of the line (e.g., arrows, circles, etc.).Subclasses must implement the following messages:	private		graphic	returns a Geometric object that can be displayedInstance Variables:	directionSymbol	&lt;#startDirection | #stopDirection&gt;	a symbol that when performed on our container, returns a unit vector of our direction	isFilled	&lt;Boolean&gt;	are we filled?	positionSymbol	&lt;#startPoint | #stopPoint&gt;	where should we be displayed at (when performed on our container returns our position)</body></comment><class><name>ArrowAnnotation</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.LineAnnotation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>length width </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ArrowAnnotation</class-id><body>ArrowAnnotation is a line annotation that displays an arrow at the end of the line.Instance Variables:	length	&lt;Integer&gt;	the length of the arrow	width	&lt;Integer&gt;	our width</body></comment><class><name>Drawing</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.CompositeFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections handles controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.Drawing</class-id><body>Drawing is a view that allows the user to interact with the figure. In addition to the composite figure behavior, it cooperates with a controller to allow the user to manipulate the figures.Instance Variables:	controller	&lt;DrawingController&gt;	my controller	handles	&lt;SequenceableCollection of: Handle&gt;	handles that the user can interact with, only selections will have their handles displayed	selections	&lt;Collection of: Figure&gt;	the figures that are currently selected by the user. Selected figures may be treated differently by different toolsClass Variables:	CopiedFigures	&lt;Collection of: Figure&gt;	a collection of figures that were copied or cut from a drawing (for cut/paste operations)</body></comment><class><name>DrawingEditor</name><environment>Refactory.HotDraw</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttons drawing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.DrawingEditor</class-id><body>DrawingEditor is the ApplicationModel for a Drawing.Instance Variables:	buttons	&lt;SelectionInList of: ButtonDescription&gt;	the selection in list of all our tools	drawing	&lt;Drawing&gt;	our drawing</body></comment><class><name>PolylineFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>points </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.PolylineFigure</class-id><body>PolylineFigure is a figure that is represented by a series of points. The default polyline figure just draws straight lines between these points, but other subclasses can draw curved lines through the points. If this figure is filled, then the start and end points should be the same.Instance Variables:	points	&lt;SequenceableCollection of: Point&gt;	our points</body></comment><class><name>SplineFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.PolylineFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.SplineFigure</class-id><body>SplineFigure is a figure that represents a spline.Instance Variables:	spline	&lt;Spline&gt;	the geometric spline object</body></comment><class><name>DiamondAnnotation</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.ArrowAnnotation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.DiamondAnnotation</class-id><body>DiamondAnnotation is a line annotation that displays a diamond shape at the end of line (similar to those in some case tool diagrams).</body></comment><class><name>CharacterTransitionTable</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.TransitionTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characterMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.CharacterTransitionTable</class-id><body>CharacterTransitionTable is a transition table for characters. It decides our next state by looking at a table of characters (or symbols for special keys -- #F1).Instance Variables:	characterMap	&lt;SequenceableCollection of: (Association key: String value: EndToolState)&gt;	a mapping for characters to the next state</body></comment><class><name>BezierFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.PolylineFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bezier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.BezierFigure</class-id><body>BezierFigure represents a bezier curve.Instance Variables:	bezier	&lt;Bezier&gt;	our curve</body></comment><class><name>LineFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.PolylineFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annotations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.LineFigure</class-id><body>LineFigure is a special PolylineFigure that can add annotations to its start and end points. These annotations can be arrows, circles, etc.Instance Variables:	annotations	&lt;SequenceableCollection of: LineAnnotation&gt;	the annotations to display on our line</body></comment><class><name>CircleAnnotation</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.LineAnnotation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>radius </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.CircleAnnotation</class-id><body>CircleAnnotation is a line annotation that displays a circle at the end of the line.Instance Variables:	radius	&lt;Integer&gt;	the radius of the circle to display</body></comment><class><name>ToolState</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.EndToolState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyPress keyRelease mouseMove redButtonPress redButtonRelease yellowButtonPress yellowButtonRelease doubleClick immediate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ToolState</class-id><body>ToolState is a state in a Tool's state machine. It inherits its action from its superclass, and has several transition tables. One for each type of event that can be processed.Instance Variables:	doubleClick	&lt;TransitionTable&gt;	where to go to for a double click event	keyPress	&lt;TransitionTable&gt;	...	keyRelease	&lt;TransitionTable&gt;		mouseMove	&lt;TransitionTable&gt;		redButtonPress	&lt;TransitionTable&gt;		redButtonRelease	&lt;TransitionTable&gt;		yellowButtonPress	&lt;TransitionTable&gt;		yellowButtonRelease	&lt;TransitionTable&gt;	</body></comment><class><name>Tool</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller cursor currentState initialState passInputDown data figure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Tools</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.Tool</class-id><body>Tool are used by drawings to manipulate the figures. They represent different strategies for manipulation. They contain a state diagram that describes their actions.Instance Variables:	controller	&lt;DrawingController&gt;	the controller for the drawing	currentState	&lt;ToolState&gt;	the state we're currently in	cursor	&lt;Cursor&gt;	the cursor that should be displayed	data	&lt;Dictionary&gt;	data that can be passed from one state to another	figure	&lt;Figure&gt;	the figure that the current event is for (this is used for efficiency)	initialState	&lt;ToolState&gt;	the state that this tool initially starts in	passInputDown	&lt;Boolean&gt;	should we pass input through to subviews or consume it ourselvesClass Variables:	Debug	&lt;Boolean&gt;	when set to true, prints the state name to the transcript when it is enter	States	&lt;Dictionary key: String value: EndToolState&gt;	our collection of tool states</body></comment><class><name>TentativePositionHandle</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.TrackHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Handles</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.TentativePositionHandle</class-id><body>TentativePositionHandle is a special handle that allows the user to create a new point on the line. Normally it is displayed between two real points on the line.Instance Variables:	index	&lt;Index&gt;	the index of the new point</body></comment><class><name>ArcFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.EllipseFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startAngle stopAngle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ArcFigure</class-id><body>ArcFigure is a figure that represents an EllipticalArc.Instance Variables:	startAngle	&lt;Integer&gt;	start angle for our ellipse	stopAngle	&lt;Integer&gt;	start angle for our ellipse</body></comment><class><name>ImageFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.CachedFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Figures</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.ImageFigure</class-id><body>ImageFigure is a cached figure that can be used to grab images from the screen.</body></comment><class><name>FigureAttributes</name><environment>Refactory.HotDraw</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineWidth lineColor fillColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><comment><class-id>Refactory.HotDraw.FigureAttributes</class-id><body>FigureAttributes is a record that holds some attibutes of figures. These attributes could be incorporated into the figures, but this saves space since most figures don't specialize these attributes.Instance Variables:	fillColor	&lt;ColorValue&gt;	if our figure is filled, this is the color to use	lineColor	&lt;ColorValue&gt;	our outline's color	lineWidth	&lt;Integer&gt;	how wide is our outline</body></comment><shared-variable><name>InsertionPoint</name><environment>Refactory.HotDraw.TextFigure</environment><private>true</private><constant>true</constant><category>resources</category><initializer>Smalltalk.Graphics.Image 				extent: 7 @ 4				depth: 1				palette: Smalltalk.Graphics.CoveragePalette monoMaskPalette				bits: #[8 28 62 62]				pad: 8</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>CopiedFigures</name><environment>Refactory.HotDraw.Drawing</environment><private>true</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Grid</name><environment>Refactory.HotDraw.Tool</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>States</name><environment>Refactory.HotDraw.Tool</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Debug</name><environment>Refactory.HotDraw.Tool</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>false</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Invisible</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>4</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Selectable</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>1</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Selected</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>32</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Connectable</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>64</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Removeable</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>8</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Moveable</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>2</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><shared-variable><name>Filled</name><environment>Refactory.HotDraw.Figure</environment><private>true</private><constant>true</constant><category>states</category><initializer>16</initializer><attributes><package>HotDraw Framework</package></attributes></shared-variable><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>accessing</category><body package="HotDraw Framework">constrain: aSelector to: aMessageSend 	"Constrain yourself to aMessageSend's value. If aSelector is a setter, then	send the message directly. If its a getter, then use the translateBy: message	to move to the new position. See PositionConstraint for details."	^PositionConstraint send: aSelector		to: self		with: aMessageSend</body><body package="HotDraw Framework">container: aContainer 	aContainer isNil ifTrue: [self delete].	super container: aContainer</body><body package="HotDraw Framework">drawing	"Return the drawing that you are located in or nil if you are not in any drawing right now."	container isNil ifTrue: [^nil].	^container drawing</body><body package="HotDraw Framework">figureAt: aPoint 	self isVisible ifFalse: [^nil].	^(self containsPoint: aPoint) ifTrue: [self] ifFalse: [nil]</body><body package="HotDraw Framework">handles	| handles |	handles := OrderedCollection withAll: (TrackHandle allCornersOf: self).	handles add: (Handle connectionOn: self at: #center).	^handles</body><body package="HotDraw Framework">menuAt: aPoint 	"Figures have a menu that pops-up when clicked on by the yellow mouse button."	| mb |	mb := MenuBuilder new.	mb		addCopyCutPaste;		line;		add: 'inspect...' -&gt; #inspect;		line.	self addLineColorMenuTo: mb.	self addFillColorMenuTo: mb.	self addLineWidthMenuTo: mb.	self addModelMenuTo: mb at: aPoint.	^mb menu</body><body package="HotDraw Framework">model	^model</body><body package="HotDraw Framework">model: anObject	model := anObject.	model addDependent: self</body><body package="HotDraw Framework">owner	^self</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>connection</category><body package="HotDraw Framework">canConnectFromFigure: aFigure 	"Can we connect from aFigure. We might want some additional checking to verify that	this is a legal operation for our drawing's sematics."	^true</body><body package="HotDraw Framework">canConnectFromPoint: aPoint 	"Should we allow outgoing connections from aPoint?"	^self canBeConnected</body><body package="HotDraw Framework">canConnectFromPoint: myPoint to: aFigure at: figurePoint 	^(self canConnectFromPoint: myPoint) and: 			[(aFigure canConnectToPoint: figurePoint) and: 					[(self canConnectToFigure: aFigure) 						and: [aFigure canConnectFromFigure: self]]]</body><body package="HotDraw Framework">canConnectToFigure: aFigure 	"Can we connect to aFigure. We might want some additional checking to verify that	this is a legal operation for our drawing's sematics."	^self canBeConnected and: [self ~~ aFigure]</body><body package="HotDraw Framework">canConnectToPoint: aPoint 	"Can we allow a connection to aPoint? If we have several 'ports' we might only allow	certain connections to some ports."	^self canBeConnected</body><body package="HotDraw Framework">connectFromPoint: myPoint to: aFigure at: figurePoint 	"Return a figure that represents the connection from self to aFigure (using myPoint	and figurePoint as the connection points)."	| newFigure |	newFigure := self connectionFigureClass connect: self to: aFigure.	self createStartConnectionConstraintFor: newFigure at: myPoint.	aFigure createStopConnectionConstraintFor: newFigure at: figurePoint.	^newFigure</body><body package="HotDraw Framework">connectionFigureClass	"The type of figure that we should use for connections"	^LineFigure</body><body package="HotDraw Framework">connectionPositions	"If we don't use a boundary constraint, try to guess a good location for the end point of the line."	^#(#origin #corner #topRight #bottomLeft #center #topCenter #rightCenter #bottomCenter #leftCenter)</body><body package="HotDraw Framework">createStartConnectionConstraintFor: newFigure at: myPoint 	"If we are a filled figure, then try connecting to our boundary (our center	must be inside us). If not filled, then try to find what part we are connecting	to/from. Subclasses can override to connect to figure parts."	self isOpaque		ifTrue: [BoundaryConstraint forFigure: self startLine: newFigure]		ifFalse: 			[| position |			position := self shortestPositionTo: myPoint.			PositionConstraint send: #startPoint:				to: newFigure				with: (MessageSend receiver: self selector: position)]</body><body package="HotDraw Framework">createStopConnectionConstraintFor: newFigure at: myPoint 	"If we are a filled figure, then try connecting to our boundary (our center	must be inside us). If not filled, then try to find what part we are connecting	to/from. Subclasses can override to connect to figure parts."	self isOpaque		ifTrue: [BoundaryConstraint forFigure: self stopLine: newFigure]		ifFalse: 			[| position |			position := self shortestPositionTo: myPoint.			PositionConstraint send: #stopPoint:				to: newFigure				with: (MessageSend receiver: self selector: position)]</body><body package="HotDraw Framework">shortestPositionTo: myPoint 	"Return a symbol from #connectionPositions that is the shortest distance from myPoint."	| min position positions |	positions := self connectionPositions.	positions isEmpty ifTrue: [^#center].	min := myPoint dist: (self perform: positions first).	position := positions first.	positions do: 			[:each | 			| dist |			dist := myPoint dist: (self perform: each).			dist &lt; min 				ifTrue: 					[min := dist.					position := each]].	^position</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>transforming</category><body package="HotDraw Framework">align: alignmentPoint with: relativePoint 	self translateBy: relativePoint - alignmentPoint</body><body package="HotDraw Framework">basicTranslateBy: aPoint 	"This method is called by #translateBy:. The #translateBy: method has already moved our	bounds. If we have other points that need to be moved, we need to move them also."</body><body package="HotDraw Framework">scaleBy: aPoint 	| center |	center := self center.	self align: center with: (center scaledBy: aPoint)</body><body package="HotDraw Framework">setBoundsTo: aRectangle 	"We have moved to aRectangle. Update our bounds, and invalidate our old and new positions."	| oldBounds |	oldBounds := self preferredBounds.	bounds := aRectangle.	self changedPreferredBounds: oldBounds.	self changed</body><body package="HotDraw Framework">translateBy: aPoint 	"Move ourself by aPoint. Instead of overriding this method, 	subclasses will probably just need to override basicTranslateBy:"	| oldBounds |	self isMoveable ifFalse: [^self].	aPoint = (0 @ 0) ifTrue: [^self].	oldBounds := self preferredBounds.	self translatePreferredBoundsBy: aPoint.	self basicTranslateBy: aPoint.	self changedPreferredBounds: oldBounds.	self changed</body><body package="HotDraw Framework">translatePreferredBoundsBy: aPoint 	bounds := self preferredBounds translatedBy: aPoint</body><body package="HotDraw Framework">translateTo: aPoint 	"Move origin to aPoint. This used to move corner to aPoint, which seemed wierd."	self translateBy: aPoint - self origin</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>testing</category><body package="HotDraw Framework">canBeConnected	^(state bitAnd: Connectable) ~~ 0</body><body package="HotDraw Framework">containedBy: aRectangle 	"Are you contained in aRectangle?"	^aRectangle contains: self bounds</body><body package="HotDraw Framework">isComposite	^false</body><body package="HotDraw Framework">isDrawing	^false</body><body package="HotDraw Framework">isHandle	^false</body><body package="HotDraw Framework">isMoveable	^(state bitAnd: Moveable) == 0</body><body package="HotDraw Framework">isOpaque	^(state bitAnd: Filled) ~~ 0</body><body package="HotDraw Framework">isRemoveable	^(state bitAnd: Removeable) == 0</body><body package="HotDraw Framework">isSelectable	^(state bitAnd: Selectable) == 0</body><body package="HotDraw Framework">isVisible	^(state bitAnd: Invisible) == 0</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>bounding box accessing</category><body package="HotDraw Framework">bottom	^self bounds bottom</body><body package="HotDraw Framework">bottomCenter	^self bounds bottomCenter</body><body package="HotDraw Framework">bottomLeft	^self bounds bottomLeft</body><body package="HotDraw Framework">bottomLeft: aPoint 	self setBoundsTo: (Rectangle vertex: aPoint x @ self origin y				vertex: self corner x @ aPoint y)</body><body package="HotDraw Framework">bottomRight	^self bounds bottomRight</body><body package="HotDraw Framework">bottomRight: aPoint 	self setBoundsTo: (Rectangle vertex: self origin vertex: aPoint)</body><body package="HotDraw Framework">center	^self bounds center</body><body package="HotDraw Framework">corner	^self bounds corner</body><body package="HotDraw Framework">corner: aPoint 	self bottomRight: aPoint</body><body package="HotDraw Framework">extent	^self bounds extent</body><body package="HotDraw Framework">left	^self bounds left</body><body package="HotDraw Framework">leftCenter	^self bounds leftCenter</body><body package="HotDraw Framework">offCenter: deltaPoint 	^self center + deltaPoint</body><body package="HotDraw Framework">offCorner: deltaPoint 	^self corner + deltaPoint</body><body package="HotDraw Framework">offOrigin: deltaPoint 	^self origin + deltaPoint</body><body package="HotDraw Framework">origin	^self bounds origin</body><body package="HotDraw Framework">origin: aPoint 	self topLeft: aPoint</body><body package="HotDraw Framework">position: aPoint offset: offsetPoint 	^self origin + (self extent * aPoint) + offsetPoint</body><body package="HotDraw Framework">right	^self bounds right</body><body package="HotDraw Framework">rightCenter	^self bounds rightCenter</body><body package="HotDraw Framework">top	^self bounds top</body><body package="HotDraw Framework">topCenter	^self bounds topCenter</body><body package="HotDraw Framework">topLeft	^self bounds topLeft</body><body package="HotDraw Framework">topLeft: aPoint 	self setBoundsTo: (Rectangle vertex: aPoint vertex: self corner)</body><body package="HotDraw Framework">topRight	^self bounds topRight</body><body package="HotDraw Framework">topRight: aPoint 	self setBoundsTo: (Rectangle vertex: self origin x @ aPoint y				vertex: aPoint x @ self corner y)</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>attribute accessing</category><body package="HotDraw Framework">attributes	^attributes isNil		ifTrue: [attributes := FigureAttributes new]		ifFalse: [attributes]</body><body package="HotDraw Framework">beInvisible	self setBit: Invisible to: true.	self invalidate</body><body package="HotDraw Framework">beVisible	self setBit: Invisible to: false.	self invalidate</body><body package="HotDraw Framework">connectable: aBoolean 	self setBit: Connectable to: aBoolean</body><body package="HotDraw Framework">deselect	self setBit: Selected to: false</body><body package="HotDraw Framework">fillColor	^(attributes isNil or: [attributes fillColor isNil])		ifTrue: 			[container isNil ifTrue: [self backgroundColor] ifFalse: [container fillColor]]		ifFalse: [attributes fillColor]</body><body package="HotDraw Framework">fillColor: aColorValue 	self attributes fillColor: aColorValue.	self invalidate</body><body package="HotDraw Framework">isSelected	^(state bitAnd: Selected) ~~ 0</body><body package="HotDraw Framework">lineColor	^(attributes isNil or: [attributes lineColor isNil])		ifTrue: 			[container isNil ifTrue: [self foregroundColor] ifFalse: [container lineColor]]		ifFalse: [attributes lineColor]</body><body package="HotDraw Framework">lineColor: aColorValue 	self attributes lineColor: aColorValue.	self invalidate</body><body package="HotDraw Framework">lineWidth	^(attributes isNil or: [attributes lineWidth isNil])		ifTrue: [container isNil ifTrue: [1] ifFalse: [container lineWidth]]		ifFalse: [attributes lineWidth]</body><body package="HotDraw Framework">lineWidth: anInteger 	self attributes lineWidth: anInteger.	self recomputePreferredBounds</body><body package="HotDraw Framework">moveable: aBoolean 	self setBit: Moveable to: aBoolean not</body><body package="HotDraw Framework">opaque	self setBit: Filled to: true.	self invalidate</body><body package="HotDraw Framework">removeable: aBoolean 	self setBit: Removeable to: aBoolean not</body><body package="HotDraw Framework">select	self setBit: Selected to: true</body><body package="HotDraw Framework">selectable: aBoolean 	self setBit: Selectable to: aBoolean not</body><body package="HotDraw Framework">transparent	self setBit: Filled to: false.	self invalidate</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>private</category><body package="HotDraw Framework">addFillColorMenuTo: aMenuBuilder 	aMenuBuilder beginSubMenuLabeled: 'fill color'.	ColorValue constantNames do: 			[:each | 			aMenuBuilder 				add: each asString -&gt; [self fillColor: (ColorValue perform: each)]].	aMenuBuilder endSubMenu</body><body package="HotDraw Framework">addLineColorMenuTo: aMenuBuilder 	aMenuBuilder beginSubMenuLabeled: 'line color'.	ColorValue constantNames do: 			[:each | 			aMenuBuilder 				add: each asString -&gt; [self lineColor: (ColorValue perform: each)]].	aMenuBuilder endSubMenu</body><body package="HotDraw Framework">addLineWidthMenuTo: aMenuBuilder 	aMenuBuilder beginSubMenuLabeled: 'line width'.	1 to: 5		do: 			[:i | 			aMenuBuilder 				add: (i printString , (i == 1 ifTrue: [' pixel'] ifFalse: [' pixels'])) 						-&gt; [self lineWidth: i]].	aMenuBuilder endSubMenu</body><body package="HotDraw Framework">addModelMenuTo: aMenuBuilder at: aPoint 	(model respondsTo: #menuAt:) 		ifTrue: 			[aMenuBuilder				line;				add: 'Model' -&gt; (model menuAt: aPoint)]		ifFalse: 			[(model respondsTo: #menu) 				ifTrue: 					[aMenuBuilder						line;						add: 'Model' -&gt; model menu]]</body><body package="HotDraw Framework">addVisibilityMenuTo: aMenuBuilder 	aMenuBuilder		beginSubMenuLabeled: 'visibility';		add: 'transparent' -&gt; #transparent;		add: 'opaque' -&gt; #opaque;		endSubMenu</body><body package="HotDraw Framework">myDependents	"Answer the receiver's dependents or nil. Copied down from Model to make dependency checking faster."	^dependents</body><body package="HotDraw Framework">myDependents: dependentsOrNil	"Set the receivers dependents. Copied down from Model to make dependency checking faster."	dependents := dependentsOrNil</body><body package="HotDraw Framework">setBit: mask to: aBoolean 	state := state bitOr: mask.	aBoolean ifFalse: [state := state bitXor: mask]</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	^self subclassResponsibility</body><body package="HotDraw Framework">displayOn: aGraphicsContext 	self isVisible ifTrue: 			[self isSelected				ifTrue: [self displaySelectedFigureOn: aGraphicsContext]				ifFalse: [self displayFigureOn: aGraphicsContext]]</body><body package="HotDraw Framework">displaySelectedFigureOn: aGraphicsContext 	^self displayFigureOn: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>changing</category><body package="HotDraw Framework">changed: anAspectSymbol with: aParameter 	super changed: anAspectSymbol with: aParameter.	self invalidate</body><body package="HotDraw Framework">delete	"This message is sent when a figure is being deleted. Default behavior is to notify dependents. For	example, this will let a line delete itself when the figures it is attached to are deleted."	self changed: #deleted with: nil</body><body package="HotDraw Framework">deletionUpdateFrom: aFigure 	"aFigure was removed from the drawing. I don't know what you want to do, so I just remove myself as a	deletion dependent of aFigure. For lines the default action is to remove the line."	aFigure removeDependent: self.	self removeDependent: aFigure</body><body package="HotDraw Framework">update: anAspectSymbol with: aParameter from: aSender 	"Somebody has justed changed. If it is as a result of a deletion dependent then it will be #deleted."	anAspectSymbol = #deleted ifTrue: [^self deletionUpdateFrom: aSender].	super update: anAspectSymbol		with: aParameter		from: aSender</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	model := nil.	state := Connectable</body><body package="HotDraw Framework">release	model removeDependent: self.	^super release</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>bounds accessing</category><body package="HotDraw Framework">bounds	"I define a graphic that is fixed in size.  Like Image, my bounds and preferredBounds are identical."	^self preferredBounds</body><body package="HotDraw Framework">computePreferredBounds	"Compute the preferredBounds of the figure. For some figures, the preferredBounds	is always set so this method is never called. For the other figures, this should	return a rectangle of the bounds."	^bounds</body><body package="HotDraw Framework">preferredBounds	^bounds isNil		ifTrue: [bounds := self computePreferredBounds]		ifFalse: [bounds]</body><body package="HotDraw Framework">recomputePreferredBounds	^self setBoundsTo: self computePreferredBounds</body></methods><methods><class-id>Refactory.HotDraw.Figure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	container := nil.	dependents := nil.	attributes := attributes copy.	bounds := self computePreferredBounds.	self deselect</body></methods><methods><class-id>Refactory.HotDraw.Figure class</class-id> <category>instance creation</category><body package="HotDraw Framework">createAt: aPoint 	^(self new)		translateTo: aPoint;		yourself</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>removing</category><body package="HotDraw Framework">remove: aFigure 	| rect |	rect := aFigure bounds.	aFigure container: nil.	components remove: aFigure ifAbsent: [].	self invalidateRectangle: rect.	^aFigure</body><body package="HotDraw Framework">removeAll: aCollection 	| rect |	aCollection isEmpty ifTrue: [^aCollection].	rect := aCollection inject: nil into: [:sum :each | sum isNil					ifTrue: [each bounds]					ifFalse: [sum merge: each bounds]].	aCollection		do: 			[:each | 			each container: nil.			components remove: each ifAbsent: []].	self invalidateRectangle: rect.	^aCollection</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>accessing</category><body package="HotDraw Framework">components	^components</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">flushCaches	super flushCaches.	components do: [:each | each flushCaches]</body><body package="HotDraw Framework">initialize	super initialize.	components := OrderedCollection new</body><body package="HotDraw Framework">release	components do: [:each | each release].	super release</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>broadcast</category><body package="HotDraw Framework">downcastEvent: aKey with: aParameter from: anInitiator 	"This is a message passed down the view structure to all subparts."	super downcastEvent: aKey		with: aParameter		from: anInitiator.	components do: 			[:each | 			each downcastEvent: aKey				with: aParameter				from: anInitiator]</body><body package="HotDraw Framework">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	components size to: 1		by: -1		do: 			[:i | 			((components at: i) downcastLocalEvent: aKey				with: aParameter				at: aPoint				from: anInitiator) ifTrue: [^true]].	^super downcastLocalEvent: aKey		with: aParameter		at: aPoint		from: anInitiator</body><body package="HotDraw Framework">flushCoordinateCaches	"Flush caches that relate to coordinate translations between this component 	and its container"	super flushCoordinateCaches.	components do: [:each | each flushCoordinateCaches]</body><body package="HotDraw Framework">newGraphicsDevice: aGraphicsDevice 	"Forward the newGraphicsDevice: aGraphicsDevice messages	to the receiver's components."	super newGraphicsDevice: aGraphicsDevice.	components do: [:component | component newGraphicsDevice: aGraphicsDevice]</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	^components contains: [:each | each containsPoint: aPoint]</body><body package="HotDraw Framework">isComposite	^true</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>control</category><body package="HotDraw Framework">componentWantingControl	"Answer the first component that wishes to take control.  Answer nil if there is	no component wanting control."	components size to: 1		by: -1		do: 			[:i | 			| obj |			obj := (components at: i) objectWantingControl.			obj notNil ifTrue: [^obj]].	^nil</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>sorting</category><body package="HotDraw Framework">bringToFront: aFigure 	| index |	index := components indexOf: aFigure ifAbsent: [^self].	index to: components size - 1		do: [:i | components at: i put: (components at: i + 1)].	components at: components size put: aFigure.	self invalidateRectangle: aFigure bounds</body><body package="HotDraw Framework">sendToBack: aFigure 	| index |	index := components indexOf: aFigure ifAbsent: [^self].	index to: 2		by: -1		do: [:i | components at: i put: (components at: i - 1)].	components at: 1 put: aFigure.	self invalidateRectangle: aFigure bounds</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>adding</category><body package="HotDraw Framework">add: aFigure 	| figureBounds |	components add: aFigure.	aFigure container: self.	figureBounds := aFigure bounds.	self invalidateRectangle: figureBounds.	self mergeBounds: figureBounds.	^aFigure</body><body package="HotDraw Framework">addAll: aCollection 	"For efficiency"	| figureBounds |	aCollection isEmpty ifTrue: [^aCollection].	components addAllLast: aCollection.	aCollection do: [:each | each container: self].	figureBounds := aCollection inject: nil into: [:sum :each | sum isNil					ifTrue: [each bounds]					ifFalse: [sum merge: each bounds]].	self invalidateRectangle: figureBounds.	self mergeBounds: figureBounds.	^aCollection</body><body package="HotDraw Framework">addFirst: aFigure 	components addLast: aFigure.	aFigure container: self.	self invalidateRectangle: aFigure bounds.	self mergeBounds: aFigure bounds.	^aFigure</body><body package="HotDraw Framework">addLast: aFigure 	components addFirst: aFigure.	aFigure container: self.	self invalidateRectangle: aFigure bounds.	self mergeBounds: aFigure bounds.	^aFigure</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>private</category><body package="HotDraw Framework">compositionBoundsFor: aComponent 	^aComponent preferredBounds</body><body package="HotDraw Framework">computePreferredBounds	| rect |	components isEmpty ifTrue: [^0 @ 0 extent: 0 @ 0].	rect := components first bounds.	2 to: components size		do: [:i | rect := rect merge: (components at: i) preferredBounds].	^rect</body><body package="HotDraw Framework">mergeBounds: aRectangle 	bounds isNil ifTrue: [^self].	self setBoundsTo: (bounds merge: aRectangle)</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	| rect |	rect := aGraphicsContext clippingBounds 				intersect: (self preferredBounds expandedBy: 1).	aGraphicsContext clippingRectangle: rect.	rect := rect expandedBy: 1.	components 		do: [:each | (each intersects: rect) ifTrue: [each displayOn: aGraphicsContext copy]]</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>transforming</category><body package="HotDraw Framework">basicTranslateBy: aPoint 	components do: [:each | each translateBy: aPoint]</body></methods><methods><class-id>Refactory.HotDraw.CompositeFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	components := components collect: [:each | each copy].	components do: [:each | each container: self]</body></methods><methods><class-id>Refactory.HotDraw.ToolbarController</class-id> <category>basic control sequence</category><body package="HotDraw Framework">controlTerminate	pressing ifFalse: [view over: nil].	^super controlTerminate</body></methods><methods><class-id>Refactory.HotDraw.ToolbarController</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	pressing := false</body></methods><methods><class-id>Refactory.HotDraw.ToolbarController</class-id> <category>control defaults</category><body package="HotDraw Framework">controlActivity	self viewHasCursor 		ifTrue: 			[self sensor redButtonPressed 				ifTrue: [self redButtonActivity]				ifFalse: [self mouseMovedOver: self sensor cursorPoint]].	^super controlActivity</body><body package="HotDraw Framework">endSelectionAt: point 	(pressingItem notNil and: [pressingItem == (view itemUnder: point)])		ifTrue: [self requestValueChange ifTrue: [model selection: pressingItem]].	pressingItem := nil.	view selecting: nil.	pressing := false</body><body package="HotDraw Framework">mouseMovedOver: point 	| item |	item := view itemUnder: point.	(item notNil and: [item isEnabled])		ifTrue: [view over: item]		ifFalse: [view over: nil]</body><body package="HotDraw Framework">moveSelectionTo: point 	pressingItem == (view itemUnder: point)		ifTrue: [view selecting: pressingItem]		ifFalse: [view selecting: nil]</body><body package="HotDraw Framework">redButtonActivity	self startSelectionAt: self sensor cursorPoint.	[self sensor redButtonPressed] 		whileTrue: 			[self moveSelectionTo: self sensor cursorPoint.			view repairDamage].	self endSelectionAt: self sensor cursorPoint</body><body package="HotDraw Framework">startSelectionAt: point 	pressing := true.	pressingItem := view itemUnder: point.	(pressingItem notNil and: [pressingItem isEnabled])		ifTrue: [view over: pressingItem]		ifFalse: [pressingItem := nil].	pressingItem notNil ifTrue: [view selecting: pressingItem]</body></methods><methods><class-id>Refactory.HotDraw.ToolbarController</class-id> <category>events</category><body package="HotDraw Framework">exitEvent: event 	super exitEvent: event.	self endSelectionAt: -1 @ -1.	self mouseMovedOver: -1 @ -1</body><body package="HotDraw Framework">mouseMovedEvent: anEvent 	pressing		ifTrue: [self moveSelectionTo: (self sensor cursorPointFor: anEvent)]		ifFalse: [self mouseMovedOver: (self sensor cursorPointFor: anEvent)]</body><body package="HotDraw Framework">redButtonPressedEvent: event 	self startSelectionAt: (self sensor cursorPointFor: event)</body><body package="HotDraw Framework">redButtonReleasedEvent: event 	self endSelectionAt: (self sensor cursorPointFor: event)</body></methods><methods><class-id>Refactory.HotDraw.BoundaryConstraint</class-id> <category>updating</category><body package="HotDraw Framework">update: anAspectSymbol with: aParameter from: aSender 	anAspectSymbol == #deleted ifTrue: [^self release].	aSender == line ifTrue: [^self updateFromLineWith: anAspectSymbol].	aSender == filledFigure ifTrue: [^self updateLinePoint].	super 		update: anAspectSymbol		with: aParameter		from: aSender</body><body package="HotDraw Framework">updateFromLineWith: anAspectSymbol 	isUpdating ifTrue: [^self].	isStart 		ifTrue: [anAspectSymbol == #stopPoint ifTrue: [^self]]		ifFalse: [anAspectSymbol == #startPoint ifTrue: [^self]].	self updateLinePoint</body><body package="HotDraw Framework">updateLinePoint	isUpdating := true.		[| current previous direction inside outside |	current := self currentPoint.	previous := self previousPoint.	(filledFigure containsPoint: current) 		ifTrue: 			[(filledFigure containsPoint: previous) 				ifTrue: 					[direction := current - previous.					direction := direction = (0 @ 0) 								ifTrue: [1 @ 0]								ifFalse: [direction unitVector].					outside := previous + (direction * (filledFigure extent r + 1)).					inside := previous]				ifFalse: 					[inside := current.					outside := previous]]		ifFalse: 			[inside := filledFigure center.			outside := current].	self movePointTo: (self findPointOnBoundaryBetweenInside: inside				andOutside: outside)] 			ensure: [isUpdating := false]</body></methods><methods><class-id>Refactory.HotDraw.BoundaryConstraint</class-id> <category>private</category><body package="HotDraw Framework">currentPoint	^isStart 		ifTrue: [line startPoint] 		ifFalse: [line stopPoint]</body><body package="HotDraw Framework">findPointOnBoundaryBetweenInside: aPoint andOutside: anotherPoint 	| newPoint insidePoint outsidePoint |	insidePoint := aPoint.	outsidePoint := anotherPoint.	[outsidePoint between: insidePoint - 1 and: insidePoint + 1] whileFalse: 			[newPoint := (insidePoint + outsidePoint) / 2.0.			(filledFigure containsPoint: newPoint) 				ifTrue: [insidePoint := newPoint]				ifFalse: [outsidePoint := newPoint]].	^outsidePoint</body><body package="HotDraw Framework">movePointTo: aPoint 	isStart 		ifTrue: [line startPoint: aPoint] 		ifFalse: [line stopPoint: aPoint]</body><body package="HotDraw Framework">previousPoint	^isStart		ifTrue: [line pointAt: 2]		ifFalse: [line pointAt: line pointsSize - 1]</body></methods><methods><class-id>Refactory.HotDraw.BoundaryConstraint</class-id> <category>initialize-release</category><body package="HotDraw Framework">figure: aFigure line: aLineFigure 	filledFigure := aFigure.	line := aLineFigure.	isUpdating := false.	filledFigure addDependent: self.	line addDependent: self</body><body package="HotDraw Framework">isStart: aBoolean 	isStart := aBoolean</body><body package="HotDraw Framework">release	filledFigure removeDependent: self.	line removeDependent: self.	super release</body></methods><methods><class-id>Refactory.HotDraw.BoundaryConstraint class</class-id> <category>instance creation</category><body package="HotDraw Framework">forFigure: aFigure startLine: aLineFigure 	^(self new) figure: aFigure line: aLineFigure;		isStart: true;		updateLinePoint;		yourself</body><body package="HotDraw Framework">forFigure: aFigure stopLine: aLineFigure 	^(self new) figure: aFigure line: aLineFigure;		isStart: false;		updateLinePoint;		yourself</body></methods><methods><class-id>Refactory.HotDraw.Handle</class-id> <category>accessing</category><body package="HotDraw Framework">menuAt: aPoint 	^Menu new</body><body package="HotDraw Framework">owner	^owner</body><body package="HotDraw Framework">owner: aFigure 	owner := aFigure</body><body package="HotDraw Framework">toolState	^toolState</body><body package="HotDraw Framework">toolState: aToolState 	toolState := aToolState</body></methods><methods><class-id>Refactory.HotDraw.Handle</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	self selectable: false.	bounds := 0 @ 0 extent: self class image bounds extent.	toolState := EndToolState name: 'No-op' command: [:tool :event | ]</body></methods><methods><class-id>Refactory.HotDraw.Handle</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext	self class image displayOn: aGraphicsContext at: self origin</body></methods><methods><class-id>Refactory.HotDraw.Handle</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	owner := nil</body></methods><methods><class-id>Refactory.HotDraw.Handle</class-id> <category>testing</category><body package="HotDraw Framework">isHandle	^true</body></methods><methods><class-id>Refactory.HotDraw.Handle class</class-id> <category>accessing</category><body package="HotDraw Framework">buildImage	^image := VisualStack				with: ((GraphicsAttributesWrapper						on: (FillingWrapper on: (Point zero extent: 6 @ 6)))							attributes: (GraphicsAttributes new paint: self handleHardColor))				with: ((GraphicsAttributesWrapper						on: (FillingWrapper on: (Point zero extent: 2 @ 2)))							attributes: (GraphicsAttributes new paint: ColorValue white))</body><body package="HotDraw Framework">handleHardColor	^ColorValue black</body><body package="HotDraw Framework">image	^image isNil 		ifTrue: [image := self buildImage] 		ifFalse: [image]</body></methods><methods><class-id>Refactory.HotDraw.Handle class</class-id> <category>corner handles</category><body package="HotDraw Framework">allCornersOf: aFigure 	^OrderedCollection 		with: (self topLeftOf: aFigure)		with: (self topRightOf: aFigure)		with: (self bottomRightOf: aFigure)		with: (self bottomLeftOf: aFigure)</body><body package="HotDraw Framework">bottomLeftOf: aFigure 	^self on: aFigure at: #bottomLeft</body><body package="HotDraw Framework">bottomRightOf: aFigure 	^self on: aFigure at: #bottomRight</body><body package="HotDraw Framework">topLeftOf: aFigure 	^self on: aFigure at: #topLeft</body><body package="HotDraw Framework">topRightOf: aFigure 	^self on: aFigure at: #topRight</body></methods><methods><class-id>Refactory.HotDraw.Handle class</class-id> <category>instance creation</category><body package="HotDraw Framework">connectionOn: aFigure at: aSymbol 	^(self on: aFigure at: aSymbol)		toolState: (Tool stateFor: 'Connection State');		yourself</body><body package="HotDraw Framework">on: aFigure at: aSymbol 	| handle |	handle := self new.	handle		owner: aFigure;		constrain: #center to: (MessageSend receiver: aFigure selector: aSymbol).	^handle</body><body package="HotDraw Framework">on: aFigure at: aSymbol offset: aPoint 	| handle |	handle := self new.	handle		owner: aFigure;		constrain: #center			to: (MessageSend 					receiver: aFigure					selector: aSymbol					arguments: (Array with: aPoint)).	^handle</body></methods><methods><class-id>Refactory.HotDraw.TrackHandle</class-id> <category>accessing</category><body package="HotDraw Framework">moveBlock	^moveBlock</body><body package="HotDraw Framework">moveBlock: aBlockClosure 	moveBlock := aBlockClosure</body></methods><methods><class-id>Refactory.HotDraw.TrackHandle class</class-id> <category>instance creation</category><body package="HotDraw Framework">bottomLeftOf: aFigure 	^(super bottomLeftOf: aFigure)		moveBlock: [:aPoint | aFigure bottomLeft: aPoint];		yourself</body><body package="HotDraw Framework">bottomRightOf: aFigure 	^(super bottomRightOf: aFigure)		moveBlock: [:aPoint | aFigure bottomRight: aPoint];		yourself</body><body package="HotDraw Framework">new	| handle |	handle := super new.	handle toolState: (Tool stateFor: 'Track Handle').	^handle</body><body package="HotDraw Framework">pointAtIndex: anIndex of: aFigure 	| handle |	handle := self new.	^handle		owner: aFigure;		constrain: #center			to: (MessageSend 					receiver: aFigure					selector: #pointAt:					arguments: (Array with: anIndex));		moveBlock: [:aPoint | aFigure pointAt: anIndex put: aPoint];		yourself</body><body package="HotDraw Framework">topLeftOf: aFigure 	^(super topLeftOf: aFigure)		moveBlock: [:aPoint | aFigure topLeft: aPoint];		yourself</body><body package="HotDraw Framework">topRightOf: aFigure 	^(super topRightOf: aFigure)		moveBlock: [:aPoint | aFigure topRight: aPoint];		yourself</body></methods><methods><class-id>Refactory.HotDraw.ButtonDescription</class-id> <category>accessing</category><body package="HotDraw Framework">disable	^self enabled: false</body><body package="HotDraw Framework">enable	^self enabled: true</body><body package="HotDraw Framework">enabled: aBoolean 	enabled := aBoolean.	(icon respondsTo: #isEnabled:) ifTrue: [icon isEnabled: aBoolean]</body><body package="HotDraw Framework">icon	^icon</body><body package="HotDraw Framework">icon: anObject	icon := anObject</body><body package="HotDraw Framework">value	^value</body><body package="HotDraw Framework">value: anObject	value := anObject</body></methods><methods><class-id>Refactory.HotDraw.ButtonDescription</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	enabled := false</body></methods><methods><class-id>Refactory.HotDraw.ButtonDescription</class-id> <category>testing</category><body package="HotDraw Framework">isEnabled	^enabled</body></methods><methods><class-id>Refactory.HotDraw.ButtonDescription class</class-id> <category>instance creation</category><body package="HotDraw Framework">icon: anIcon value: anObject 	^(self new)		icon: anIcon;		enable;		value: anObject;		yourself</body><body package="HotDraw Framework">new	^super new initialize</body><body package="HotDraw Framework">spacer	^self spacer: 12 @ 12</body><body package="HotDraw Framework">spacer: extent 	^(self new)		icon: ((VisualRegion new)					extent: extent;					lineWidth: 0;					yourself);		disable;		yourself</body></methods><methods><class-id>Refactory.HotDraw.CachedFigure</class-id> <category>accessing</category><body package="HotDraw Framework">handles	^Handle allCornersOf: self</body><body package="HotDraw Framework">origin: aPoint 	bounds := aPoint extent: self cache extent</body></methods><methods><class-id>Refactory.HotDraw.CachedFigure</class-id> <category>transforming</category><body package="HotDraw Framework">computePreferredBounds	^bounds isNil 		ifTrue: [0 @ 0 extent: self cache extent] 		ifFalse: [bounds]</body></methods><methods><class-id>Refactory.HotDraw.CachedFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">flushCaches	super flushCaches.	cache := nil</body><body package="HotDraw Framework">initialize	super initialize.	self opaque</body></methods><methods><class-id>Refactory.HotDraw.CachedFigure</class-id> <category>private</category><body package="HotDraw Framework">cache	^cache isNil 		ifTrue: [cache := self fillCache] 		ifFalse: [cache]</body><body package="HotDraw Framework">fillCache	"Draw each of my component Figures onto my cache."	^self subclassResponsibility</body></methods><methods><class-id>Refactory.HotDraw.CachedFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGC 	self cache displayOn: aGC at: self origin rounded</body></methods><methods><class-id>Refactory.HotDraw.CachedFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	cache := cache copy</body></methods><methods><class-id>Refactory.HotDraw.IndexedTrackHandle</class-id> <category>accessing</category><body package="HotDraw Framework">menuAt: aPoint 	| menu |	menu := super menuAt: aPoint.	menu addItemLabel: 'Remove' value: #removePoint.	^menu</body><body package="HotDraw Framework">removePoint	owner removePointAtIndex: index</body></methods><methods><class-id>Refactory.HotDraw.IndexedTrackHandle</class-id> <category>initialize-release</category><body package="HotDraw Framework">index: anObject	index := anObject</body></methods><methods><class-id>Refactory.HotDraw.IndexedTrackHandle class</class-id> <category>instance creation</category><body package="HotDraw Framework">pointAtIndex: anIndex of: aFigure 	| handle |	handle := super pointAtIndex: anIndex of: aFigure.	handle index: anIndex.	^handle</body></methods><methods><class-id>Refactory.HotDraw.TransitionTable</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize</body></methods><methods><class-id>Refactory.HotDraw.TransitionTable</class-id> <category>accessing</category><body package="HotDraw Framework">goto: aState	^self subclassResponsibility</body><body package="HotDraw Framework">nextStateForTool: aTool event: anEvent	^self subclassResponsibility</body></methods><methods><class-id>Refactory.HotDraw.TransitionTable class</class-id> <category>instance creation</category><body package="HotDraw Framework">new	^super new initialize</body></methods><methods><class-id>Refactory.HotDraw.SimpleTransitionTable</class-id> <category>initialize-release</category><body package="HotDraw Framework">nextState: anObject	nextState := anObject</body></methods><methods><class-id>Refactory.HotDraw.SimpleTransitionTable</class-id> <category>accessing</category><body package="HotDraw Framework">goto: aState	self nextState: aState</body><body package="HotDraw Framework">nextStateForTool: aTool event: anEvent	^nextState</body></methods><methods><class-id>Refactory.HotDraw.SimpleTransitionTable class</class-id> <category>instance creation</category><body package="HotDraw Framework">goto: aToolState 	^(self new) nextState: aToolState;		yourself</body></methods><methods><class-id>Refactory.HotDraw.EllipseFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	"Display an ellipse on aGraphicsContext. If the ellipse figure is not transparent then 	display a filled ellipse using the current fillColor."	self isOpaque ifTrue: [self displayFilledOn: aGraphicsContext].	self lineWidth &gt; 0 ifTrue: [self displayOutlineOn: aGraphicsContext]</body><body package="HotDraw Framework">displayFilledOn: aGraphicsContext 	aGraphicsContext paint: self fillColor.	aGraphicsContext 		displayWedgeBoundedBy: self bounds		startAngle: self startAngle		sweepAngle: self sweepAngle</body><body package="HotDraw Framework">displayOutlineOn: aGraphicsContext 	aGraphicsContext lineWidth: self lineWidth.	aGraphicsContext paint: self lineColor.	aGraphicsContext 		displayArcBoundedBy: self bounds		startAngle: self startAngle		sweepAngle: self sweepAngle</body></methods><methods><class-id>Refactory.HotDraw.EllipseFigure</class-id> <category>private</category><body package="HotDraw Framework">startAngle	^0</body><body package="HotDraw Framework">sweepAngle	^360</body></methods><methods><class-id>Refactory.HotDraw.EllipseFigure</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	^self isOpaque		ifTrue: 			[(EllipticalArc boundingBox: self preferredBounds				startAngle: self startAngle				sweepAngle: self sweepAngle) regionIntersects: (aPoint - 1 extent: 2 @ 2)]		ifFalse: 			[(EllipticalArc boundingBox: self preferredBounds				startAngle: self startAngle				sweepAngle: self sweepAngle) outlineIntersects: (aPoint - 1 extent: 2 @ 2)]</body></methods><methods><class-id>Refactory.HotDraw.EllipseFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">ellipse: aRectangle 	bounds := aRectangle.	self opaque</body></methods><methods><class-id>Refactory.HotDraw.EllipseFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">createAt: aPoint 	^self ellipse: (aPoint extent: 0 @ 0)</body><body package="HotDraw Framework">ellipse: anEllipse 	^self new ellipse: anEllipse</body></methods><methods><class-id>Refactory.HotDraw.ToolbarView</class-id> <category>controller accessing</category><body package="HotDraw Framework">defaultControllerClass	^ToolbarController</body><body package="HotDraw Framework">itemUnder: aPoint 	self buttonsAndPositionsDo: 			[:each :point | 			((point extent: each icon extent) containsPoint: aPoint) ifTrue: [^each]].	^nil</body><body package="HotDraw Framework">mouseMovedOver: aPoint 	self over: (self itemUnder: aPoint)</body></methods><methods><class-id>Refactory.HotDraw.ToolbarView</class-id> <category>accessing</category><body package="HotDraw Framework">buttons	^self model list</body><body package="HotDraw Framework">horizontal	^horizontal</body><body package="HotDraw Framework">horizontal: aBoolean 	horizontal := aBoolean.	self invalidate</body><body package="HotDraw Framework">invalidateOverIcon	over notNil 		ifTrue: 			[self				invalidateRectangle: ((self boundsFor: over) expandedBy: self spacer)				repairNow: false]</body><body package="HotDraw Framework">invalidateSelectedIcon	selecting notNil 		ifTrue: 			[self 				invalidateRectangle: ((self boundsFor: selecting) expandedBy: self spacer)				repairNow: false]</body><body package="HotDraw Framework">over	^over</body><body package="HotDraw Framework">over: anObject 	over == anObject ifTrue: [^self].	self invalidateOverIcon.	over := anObject.	self invalidateOverIcon</body><body package="HotDraw Framework">selecting: anObject 	selecting == anObject ifTrue: [^self].	self invalidateSelectedIcon.	selecting := anObject.	self invalidateSelectedIcon</body></methods><methods><class-id>Refactory.HotDraw.ToolbarView</class-id> <category>private</category><body package="HotDraw Framework">boundsFor: aButton 	self buttonsAndPositionsDo: 			[:each :point | 			each == aButton ifTrue: [^point extent: each icon extent]].	^1 @ 1 extent: 0 @ 0</body><body package="HotDraw Framework">buttonsAndPositionsDo: aBlock 	self buttons inject: self startPosition		into: 			[:pos :each | 			aBlock value: each value: pos.			pos + (horizontal						ifTrue: [(each icon extent x + self spacer) @ 0]						ifFalse: [0 @ (each icon extent y + self spacer)])]</body><body package="HotDraw Framework">isSelected: anObject 	^model selection == anObject</body><body package="HotDraw Framework">overBorder	^BeveledBorder raised</body><body package="HotDraw Framework">selectedBorder	^BeveledBorder inset</body><body package="HotDraw Framework">spacer	^5</body><body package="HotDraw Framework">startPosition	^self spacer @ self spacer</body></methods><methods><class-id>Refactory.HotDraw.ToolbarView</class-id> <category>displaying</category><body package="HotDraw Framework">display: each at: point on: aGraphicsContext 	| inset |	inset := selecting == each or: [self isSelected: each].	each icon 		displayOn: aGraphicsContext		at: point + (inset ifTrue: [1] ifFalse: [0]).	(each == over and: [inset not]) 		ifTrue: 			[self overBorder 				displayOn: aGraphicsContext				forDisplayBox: ((point extent: each icon extent) expandedBy: 3 @ 3)				using: self].	inset 		ifTrue: 			[self selectedBorder 				displayOn: aGraphicsContext				forDisplayBox: ((point extent: each icon extent) expandedBy: 3 @ 3)				using: self]</body><body package="HotDraw Framework">displayBackgroundOn: aGraphicsContext 	aGraphicsContext paint: self backgroundColor.	aGraphicsContext displayRectangle: aGraphicsContext clippingBounds</body><body package="HotDraw Framework">displayForegroundOn: aGraphicsContext 	self buttonsAndPositionsDo: 			[:each :point | 			self 				display: each				at: point				on: aGraphicsContext]</body><body package="HotDraw Framework">displayOn: aGraphicsContext 	self displayBackgroundOn: aGraphicsContext.	self displayForegroundOn: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.ToolbarView</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	horizontal := true</body></methods><methods><class-id>Refactory.HotDraw.RectangleFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	"Display an ellipse on aGraphicsContext. If the ellipse figure is not transparent then 	display a filled ellipse using the current fillColor."	self isOpaque ifTrue: [self displayFilledOn: aGraphicsContext].	self lineWidth &gt; 0 ifTrue: [self displayOutlineOn: aGraphicsContext]</body><body package="HotDraw Framework">displayFilledOn: aGraphicsContext 	aGraphicsContext paint: self fillColor.	self bounds displayFilledOn: aGraphicsContext</body><body package="HotDraw Framework">displayOutlineOn: aGraphicsContext 	aGraphicsContext lineWidth: self lineWidth.	aGraphicsContext paint: self lineColor.	self bounds displayStrokedOn: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.RectangleFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">rectangle: aRectangle 	bounds := aRectangle.	self opaque</body></methods><methods><class-id>Refactory.HotDraw.RectangleFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">createAt: aPoint 	^self rectangle: (aPoint extent: 0 @ 0)</body><body package="HotDraw Framework">rectangle: aRectangle 	^(self new)		rectangle: aRectangle;		yourself</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>accessing</category><body package="HotDraw Framework">copyFrom: startIndex to: stopIndex 	^paragraph asText copyFrom: startIndex to: stopIndex</body><body package="HotDraw Framework">handles	| handles |	handles := OrderedCollection new.	handles add: (Handle connectionOn: self at: #origin).	handles add: ((TrackHandle topRightOf: self) 				moveBlock: [:aPoint | self moveMarginTo: aPoint]).	^handles</body><body package="HotDraw Framework">indexForPoint: aPoint 	"Answer the index into my text that most closely corresponds to aPoint."	^(paragraph characterBlockAtPoint: aPoint - self origin) stringIndex</body><body package="HotDraw Framework">margin	^self extent x</body><body package="HotDraw Framework">margin: aNumber 	paragraph compositionWidth: aNumber rounded.	self recomputePreferredBounds.	^aNumber</body><body package="HotDraw Framework">menuAt: aPoint 	| mb |	mb := MenuBuilder new.	self addJustificationMenuTo: mb.	self addVisibilityMenuTo: mb.	self addStyleMenuTo: mb.	^(mb menu)		addItem: ((MenuItem labeled: 'other')					submenu: (super menuAt: aPoint);					yourself);		yourself</body><body package="HotDraw Framework">paragraph	^paragraph</body><body package="HotDraw Framework">print: anObject 	self string: anObject printString</body><body package="HotDraw Framework">replaceFrom: startIndex to: stopIndex with: aText 	paragraph := (paragraph copy)				replaceFrom: startIndex					to: stopIndex					with: aText;				yourself.	self margin: paragraph rightMarginForComposition</body><body package="HotDraw Framework">replaceSelectionWith: aText 	self 		replaceFrom: selection first		to: selection last - 1		with: aText</body><body package="HotDraw Framework">selectedIndices	^selection</body><body package="HotDraw Framework">setIndices: newIndices 	"Set the indices of the highlighted part --- newly added"	newIndices notNil 		ifTrue: 			[(selection notNil and: [selection first = newIndices first 				and: [selection last = newIndices last]]) 					ifFalse: 						[selection := newIndices.						self changed]]		ifFalse: 			[selection notNil 				ifTrue: 					[selection := nil.					self changed]]</body><body package="HotDraw Framework">string	^paragraph asString</body><body package="HotDraw Framework">string: aString 	self text: aString asText</body><body package="HotDraw Framework">text: aText 	paragraph := aText asComposedText</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayCaretOn: aGraphicsContext 	"Show a caret in between characters anInteger and anInteger+1. Actually, reverse the	image of a caret at this point. Thus we can toggle the caret on and off by calling this method	repeatedly."	| aPoint aBlock |	aBlock := self paragraph characterBlockForIndex: selection first.	aPoint := (aBlock left - (InsertionPoint width // 2)) 				@ (aBlock top + self paragraph textStyle baseline).	InsertionPoint displayOn: aGraphicsContext at: self origin + aPoint</body><body package="HotDraw Framework">displayEditOn: aGraphicsContext 	selection isNil ifTrue: [^self].	selection first = selection last 		ifTrue: [self displayCaretOn: aGraphicsContext]		ifFalse: [self highlightOn: aGraphicsContext]</body><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	"If I am opaque, draw a box in the background color obscuring those figures beneath me."	self isOpaque 		ifTrue: 			[aGraphicsContext				paint: self fillColor;				displayRectangle: self bounds].	aGraphicsContext		paint: self lineColor;		display: paragraph at: self origin</body><body package="HotDraw Framework">displaySelectedFigureOn: aGraphicsContext 	self displayFigureOn: aGraphicsContext.	self displayEditOn: aGraphicsContext</body><body package="HotDraw Framework">highlightOn: aGraphicsContext 	"Display the image of my text from start to stop. Note they may not be in the proper	order."	| startPoint stopPoint lineRange first last start stop |	start := selection first.	stop := selection last.	start = stop ifTrue: [^self].	startPoint := paragraph characterBlockForIndex: (start min: stop).	stopPoint := paragraph characterBlockForIndex: (start max: stop).	aGraphicsContext paint: self selectionBackgroundColor.	startPoint top = stopPoint top 		ifTrue: 			[aGraphicsContext displayRectangle: (startPoint origin + self origin 						corner: stopPoint bottomLeft + self origin).			aGraphicsContext paint: self selectionForegroundColor.			^paragraph 				displayFromCharacter: startPoint stringIndex				to: stopPoint stringIndex - 1				startX: startPoint left + self origin x				forTranslation: self origin				on: aGraphicsContext].	lineRange := paragraph 				lineRangeFor: (startPoint origin corner: stopPoint corner).	first := (paragraph lineAt: lineRange first) first.	last := (paragraph lineAt: lineRange last) last.	first := first max: startPoint stringIndex.	last := last min: stopPoint stringIndex - 1.	aGraphicsContext displayRectangle: (startPoint origin + self origin 				corner: self extent x @ startPoint bottom + self origin).	aGraphicsContext 		displayRectangle: (self origin x @ (startPoint bottom + self origin y) 				corner: self extent x @ stopPoint top + self origin).	aGraphicsContext 		displayRectangle: (self origin x @ (startPoint bottom + self origin y) 				corner: stopPoint bottomLeft + self origin).	aGraphicsContext paint: self selectionForegroundColor.	paragraph 		displayFromCharacter: first		to: last		startX: startPoint left + self origin x		forTranslation: self origin		on: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">setParagraph: aParagraph origin: aPoint 	paragraph := aParagraph.	paragraph width = 0 		ifTrue: [paragraph compositionWidth: self defaultCompositionWidth].	bounds := aPoint extent: 0 @ 0.	self		recomputePreferredBounds;		setIndices: nil</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>transforming</category><body package="HotDraw Framework">moveMarginTo: aPoint	| newMargin |	newMargin := (aPoint - self origin) x.	newMargin &lt;= 0 ifTrue: [^self].	newMargin = self extent x ifTrue: [^self].	self margin: newMargin</body><body package="HotDraw Framework">recompose	"Recompose my paragraph, resetting the width and possibly the right margin."	self margin: paragraph composeAll</body><body package="HotDraw Framework">textStyle: aTextStyle 	aTextStyle alignment = paragraph textStyle alignment 		ifTrue: [paragraph textStyle: aTextStyle]		ifFalse: 			[paragraph textStyle: ((aTextStyle copy)						alignment: paragraph textStyle alignment;						yourself)]</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>private</category><body package="HotDraw Framework">addJustificationMenuTo: aMenuBuilder 	aMenuBuilder beginSubMenuLabeled: 'justification'.	#('flush left' 'centered' 'flush right' 'justified') 		with: #(#leftFlush #centered #rightFlush #justified)		do: [:label :symbol | aMenuBuilder add: label -&gt; [self alignUsing: symbol]].	aMenuBuilder endSubMenu</body><body package="HotDraw Framework">addStyleMenuTo: aMenuBuilder 	aMenuBuilder beginSubMenuLabeled: 'style'.	#(#bold #italic #underline #strikeout #default #large #small #fixed) 		do: [:each | aMenuBuilder add: each -&gt; [self styleUsing: each]].	aMenuBuilder endSubMenu</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>formatting</category><body package="HotDraw Framework">alignUsing: aSymbol 	self margin: self margin.	paragraph textStyle: paragraph textStyle copy.	paragraph perform: aSymbol.	self changed</body><body package="HotDraw Framework">styleUsing: aSymbol 	| start stop |	selection isNil 		ifTrue: 			[start := 1.			stop := paragraph asString size]		ifFalse: 			[start := selection first.			stop := selection last - 1].	self paragraph asText 		emphasizeFrom: start		to: stop		with: aSymbol.	self recompose</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>defaults</category><body package="HotDraw Framework">defaultCompositionWidth	^100</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>attribute accessing</category><body package="HotDraw Framework">deselect	super deselect.	selection notNil 		ifTrue: 			[selection := nil.			self changed]</body><body package="HotDraw Framework">select	super select.	self changed</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>bounds accessing</category><body package="HotDraw Framework">computePreferredBounds	| extent |	extent := paragraph width @ paragraph height.	^self origin extent: extent</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>editing</category><body package="HotDraw Framework">respondToEvent: event 	| character offset replacement startIndex |	character := event keyValue.	offset := 0.	(character == Character backspace or: [character == Character del]) 		ifTrue: 			[self selectedIndices size = 1 ifTrue: [offset := -1].			replacement := Text new]		ifFalse: [replacement := (String with: character) asText].	startIndex := self selectedIndices first.	self 		replaceFrom: (startIndex + offset max: 1)		to: self selectedIndices last - 1		with: replacement.	startIndex := startIndex + replacement size + offset max: 1.	self setIndices: (startIndex to: startIndex)</body></methods><methods><class-id>Refactory.HotDraw.TextFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	paragraph := paragraph copy</body></methods><methods><class-id>Refactory.HotDraw.TextFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">createAt: aPoint with: aString 	^self string: aString at: aPoint</body><body package="HotDraw Framework">paragraph: aParagraph at: aPoint 	^self new setParagraph: aParagraph origin: aPoint</body><body package="HotDraw Framework">string: aString 	^self string: aString at: 0 @ 0</body><body package="HotDraw Framework">string: aString at: aPoint 	^self paragraph: aString asComposedText at: aPoint</body></methods><methods><class-id>Refactory.HotDraw.EndToolState</class-id> <category>printing</category><body package="HotDraw Framework">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Refactory.HotDraw.EndToolState</class-id> <category>accessing</category><body package="HotDraw Framework">command	^command</body><body package="HotDraw Framework">command: anObject	command := anObject</body><body package="HotDraw Framework">name	^name</body><body package="HotDraw Framework">name: anObject	name := anObject</body></methods><methods><class-id>Refactory.HotDraw.EndToolState</class-id> <category>tool-accessing</category><body package="HotDraw Framework">evaluateIn: aTool event: anEvent 	command		value: aTool		value: anEvent</body><body package="HotDraw Framework">nextStateForEvent: anEvent tool: aTool 	^nil</body></methods><methods><class-id>Refactory.HotDraw.EndToolState</class-id> <category>testing</category><body package="HotDraw Framework">isEndState	^true</body></methods><methods><class-id>Refactory.HotDraw.EndToolState class</class-id> <category>instance creation</category><body package="HotDraw Framework">name: aString command: aBlock 	^(self new) name: aString;		command: aBlock;		yourself</body></methods><methods><class-id>Refactory.HotDraw.RoundedRectangleFigure</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	(super containsPoint: aPoint) ifFalse: [^false].	(aPoint x between: self origin x + self inset x		and: self corner x - self inset x) ifTrue: [^true].	(aPoint y between: self origin y + self inset y		and: self corner y - self inset y) ifTrue: [^true].	^self arcs 		contains: [:each | each regionIntersects: (aPoint - 1 extent: 2 @ 2)]</body></methods><methods><class-id>Refactory.HotDraw.RoundedRectangleFigure</class-id> <category>private</category><body package="HotDraw Framework">arcs	(inset x &lt;= 0 or: [inset y &lt;= 0]) ifTrue: [^#()].	^Array 		with: (EllipticalArc 				boundingBox: (self origin corner: self origin + (self inset * 2))				startAngle: 180				sweepAngle: 90)		with: (EllipticalArc 				boundingBox: (self corner - (self inset * 2) corner: self corner)				startAngle: 0				sweepAngle: 90)		with: (EllipticalArc 				boundingBox: (Rectangle 						vertex: self bottomLeft + (self inset x @ self inset y negated * 2) 						vertex: self bottomLeft)				startAngle: 90				sweepAngle: 90)		with: (EllipticalArc 				boundingBox: (Rectangle 						vertex: self topRight + (self inset x negated @ self inset y * 2)						vertex: self topRight)				startAngle: 270				sweepAngle: 90)</body><body package="HotDraw Framework">inset	inset x &lt;= 0 ifTrue: [^0 @ 0].	inset y &lt;= 0 ifTrue: [^0 @ 0].	^inset min: self extent // 2</body><body package="HotDraw Framework">inset: aPoint	inset := aPoint.	self changed</body><body package="HotDraw Framework">insetPosition	^self origin + inset</body></methods><methods><class-id>Refactory.HotDraw.RoundedRectangleFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFilledOn: aGraphicsContext 	| xinset yinset |	aGraphicsContext paint: self fillColor.	xinset := (self inset x - 1) @ 0.	(self origin + xinset corner: self corner - xinset) 		displayFilledOn: aGraphicsContext.	yinset := 0 @ (self inset y - 1).	(self origin + yinset corner: self corner - yinset) 		displayFilledOn: aGraphicsContext.	self arcs do: [:each | each displayFilledOn: aGraphicsContext]</body><body package="HotDraw Framework">displayOutlineOn: aGraphicsContext 	| xinset yinset |	aGraphicsContext		lineWidth: self lineWidth;		paint: self lineColor.	xinset := (self inset x - 1) @ 0.	(LineSegment from: self origin + xinset to: self topRight - xinset) 		displayStrokedOn: aGraphicsContext.	(LineSegment from: self bottomLeft + xinset to: self corner - xinset) 		displayStrokedOn: aGraphicsContext.	yinset := 0 @ (self inset y - 1).	(LineSegment from: self origin + yinset to: self bottomLeft - yinset) 		displayStrokedOn: aGraphicsContext.	(LineSegment from: self topRight + yinset to: self corner - yinset) 		displayStrokedOn: aGraphicsContext.	self arcs do: [:each | each displayStrokedOn: aGraphicsContext]</body></methods><methods><class-id>Refactory.HotDraw.RoundedRectangleFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	inset := 20 @ 20</body></methods><methods><class-id>Refactory.HotDraw.RoundedRectangleFigure</class-id> <category>accessing</category><body package="HotDraw Framework">handles	| handles |	handles := OrderedCollection withAll: super handles.	handles add: ((TrackHandle on: self at: #insetPosition)				moveBlock: [:aPoint | self inset: (aPoint - self origin max: 0 @ 0)];				yourself).	^handles</body></methods><methods><class-id>Refactory.HotDraw.PositionConstraint</class-id> <category>updating</category><body package="HotDraw Framework">evaluate	message last == $:		ifTrue: [receiver perform: message with: position value]		ifFalse: [receiver translateBy: position value - (receiver perform: message)]</body><body package="HotDraw Framework">update: anAspectSymbol with: aParameter from: aSender 	"If one of our figures was removed from the drawing, disconnect ourself from the figures."	anAspectSymbol == #deleted ifTrue: [^self release].	aSender == receiver 		ifTrue: 			[isUpdating 				ifFalse: 					[isUpdating := true.					[self evaluate] ensure: [isUpdating := false]]]		ifFalse: [self evaluate]</body></methods><methods><class-id>Refactory.HotDraw.PositionConstraint</class-id> <category>initialize-release</category><body package="HotDraw Framework">location: aMessageSend receiver: anObject sending: aSelector 	position := aMessageSend.	(position receiver isKindOf: Figure)		ifTrue: [position receiver addDependent: self].	receiver := anObject.	receiver addDependent: self.	message := aSelector.	isUpdating := false</body><body package="HotDraw Framework">release	position receiver removeDependent: self.	receiver removeDependent: self.	super release</body></methods><methods><class-id>Refactory.HotDraw.PositionConstraint class</class-id> <category>instance creation</category><body package="HotDraw Framework">send: aSelector to: anObject with: aMessageSend 	^(self new) location: aMessageSend			receiver: anObject			sending: aSelector;		evaluate;		yourself</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">release	component release.	super release</body><body package="HotDraw Framework">view: aView in: aRectangle 	bounds := aRectangle.	component := aView.	component container: self.	component bounds: (0 @ 0 extent: aRectangle extent)</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>private</category><body package="HotDraw Framework">changedBounds: oldBounds forComponent: aVisualComponent	"The bounds of aVisualComponent has changed from oldBounds.	Do nothing since the receiver has its own notion of bounds."	^self</body><body package="HotDraw Framework">changedContainer	super changedContainer.	container isNil ifTrue: [^self].	self setOccluded.</body><body package="HotDraw Framework">changedPreferredBounds: oldPreferredBounds forComponent: aVisualComponent	"The preferred bounds of aVisualComponent has changed from	oldPreferredBounds."	"Do nothing since the receiver has its own notion of bounds."	^self</body><body package="HotDraw Framework">compositionBoundsFor: aVisualPart 	"The receiver is a container for aVisualPart.	An actual bounding rectangle is being searched for by	aVisualPart. Forward to the receiver's container."	^container isNil ifTrue: [self bounds] ifFalse: [0 @ 0 extent: self extent]</body><body package="HotDraw Framework">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	^super		downcastLocalEvent: aKey		with: aParameter		at: (aPoint translatedBy: self origin negated)		from: anInitiator</body><body package="HotDraw Framework">graphicsContextFor: aVisualComponent	"Answer a GraphicsContext set-up for aVisualComponent."	| gc |	gc := container graphicsContextFor: self.	gc intersectClip: self bounds.	gc translateBy: self origin.	^gc</body><body package="HotDraw Framework">invalidateRectangle: aRectangle repairNow: aBoolean forComponent: aVisualComponent 	"Propagate damage up the hierarchy after translating and clipping."	| rect |	container isNil ifTrue: [^self].	rect := aRectangle translatedBy: self origin.	(self intersects: rect) 		ifTrue: 			[container 				invalidateRectangle: (self bounds intersect: rect)				repairNow: aBoolean				forComponent: self]</body><body package="HotDraw Framework">localPointToGlobal: aPoint 	"Convert a point in local coordinates to a point in the top window's coordinate system."	^aPoint translatedBy: (container localPointToGlobal: self origin)</body><body package="HotDraw Framework">setComponentBoundsTo: newBounds 	component bounds: (0 @ 0 extent: newBounds extent)</body><body package="HotDraw Framework">setOccluded	self downcastEvent: #useInvalidation		with: true		from: self</body><body package="HotDraw Framework">visualComponentsIn: aVisualComponent do: aBlock 	"This is a hack to go over the components of aVisualComponent"	aBlock value: aVisualComponent.	(aVisualComponent respondsTo: #component)		ifTrue: [self visualComponentsIn: aVisualComponent component do: aBlock].	(aVisualComponent respondsTo: #components) ifTrue: 			[aVisualComponent components				do: [:each | self visualComponentsIn: each component do: aBlock]]</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	component := component copy</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>changing</category><body package="HotDraw Framework">delete	| topComponent |	topComponent := self topComponent.	topComponent isNil ifTrue: [^self].	self visualComponentsIn: self		do: 			[:each | 			topComponent keyboardProcessor keyboardConsumers remove: each ifAbsent: []].	super delete</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>control</category><body package="HotDraw Framework">objectWantingControl	"Answer the first component that wishes to take control.  Answer nil if there is	no component wanting control."	^component objectWantingControl</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	self isOpaque ifTrue: 			[aGraphicsContext paint: self fillColor;				displayRectangle: self bounds;				paint: self lineColor].	aGraphicsContext intersectClip: self bounds.	aGraphicsContext translateBy: self origin.	component displayOn: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>broadcast</category><body package="HotDraw Framework">downcastEvent: aKey with: aParameter from: anInitiator 	"This is a message passed down the view structure to all subparts."	super downcastEvent: aKey		with: aParameter		from: anInitiator.	component downcastEvent: aKey		with: aParameter		from: anInitiator</body><body package="HotDraw Framework">flushCoordinateCaches	"Flush caches that relate to coordinate translations between this component 	and its container"	super flushCoordinateCaches.	component flushCoordinateCaches</body><body package="HotDraw Framework">newGraphicsDevice: aGraphicsDevice 	"Forward the newGraphicsDevice: aGraphicsDevice messages	to the receiver's components."	super newGraphicsDevice: aGraphicsDevice.	component newGraphicsDevice: aGraphicsDevice</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>accessing</category><body package="HotDraw Framework">component	^component</body><body package="HotDraw Framework">component: aVisualComponent 	component := aVisualComponent</body><body package="HotDraw Framework">container: aContainer 	super container: aContainer.	aContainer isNil ifTrue: [^self].	self visualComponentsIn: self		do: [:each | (each isKindOf: ComposedTextView) ifTrue: [each initializeSelection]]</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>event driven</category><body package="HotDraw Framework">handlerForMouseEvent: anEvent 	^component handlerForMouseEvent: anEvent</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure</class-id> <category>bounds changing</category><body package="HotDraw Framework">changedPreferredBounds: aRectangle 	component bounds: self bounds.	super changedPreferredBounds: aRectangle</body></methods><methods><class-id>Refactory.HotDraw.ViewAdapterFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">view: aView in: aRectangle 	^self new view: aView in: aRectangle</body></methods><methods><class-id>Refactory.HotDraw.DrawingController</class-id> <category>events</category><body package="HotDraw Framework">enterEvent: anEvent	self currentTool cursor show.	self handleEvent: anEvent.	^super enterEvent: anEvent</body><body package="HotDraw Framework">exitEvent: anEvent	Cursor normal show.	self handleEvent: anEvent.	^super exitEvent: anEvent</body><body package="HotDraw Framework">mouseWheelEvent: event	view upcastEvent: #mouseWheel with: event up from: self view</body></methods><methods><class-id>Refactory.HotDraw.DrawingController</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	tool := Tool selectionTool asValue.	tool value controller: self</body><body package="HotDraw Framework">tool: aValueModel 	tool := aValueModel.	tool onChangeSend: #changedTool to: self.	self changedTool</body></methods><methods><class-id>Refactory.HotDraw.DrawingController</class-id> <category>menu processing</category><body package="HotDraw Framework">localMenuItem: aSymbol 	"Answer an Array of Symbols that represent the menu messages that should be sent to my	View as opposed to my Model."	^#(#cut #paste #copySelection #group #ungroup) includes: aSymbol</body><body package="HotDraw Framework">processMenuAt: globalPoint local: localPoint for: aFigure 	| valueResult |	valueResult := self 				trackMenu: (aFigure menuAt: localPoint)				at: globalPoint				centered: true.	valueResult isNil ifTrue: [^self].	(valueResult isKindOf: MenuItem) 		ifTrue: [valueResult := valueResult value].	valueResult isSymbol 		ifTrue: 			[(self localMenuItem: valueResult) 				ifTrue: 					[aFigure isDrawing ifFalse: [view selection: aFigure].					view perform: valueResult]				ifFalse: 					[(aFigure model notNil and: [aFigure model respondsTo: valueResult]) 						ifTrue: [aFigure model perform: valueResult]						ifFalse: [aFigure perform: valueResult]]]		ifFalse: [valueResult value]</body></methods><methods><class-id>Refactory.HotDraw.DrawingController</class-id> <category>accessing</category><body package="HotDraw Framework">currentTool	^tool value</body></methods><methods><class-id>Refactory.HotDraw.DrawingController</class-id> <category>changing</category><body package="HotDraw Framework">changedTool	view clearSelections.	(self currentTool)		controller: self;		selected.	self currentTool cursor show.	self setAsCurrentConsumer</body></methods><methods><class-id>Refactory.HotDraw.DrawingController</class-id> <category>event driven</category><body package="HotDraw Framework">desiresFocus	^true</body><body package="HotDraw Framework">handleEvent: anEvent 	anEvent key == #enter ifTrue: [self currentTool cursor show].	anEvent key == #exit ifTrue: [Cursor normal show].	(anEvent isMouseEvent and: [anEvent isMouseWheelEvent]) ifTrue: [^super handleEvent: anEvent]. 	(anEvent isMouseEvent or: [anEvent isKeyboard]) 		ifTrue: 			[(self currentTool handleEvent: anEvent) 				ifTrue: [self setAsCurrentConsumer]]</body><body package="HotDraw Framework">setAsCurrentConsumer	| ctrl |	self keyboardProcessor isNil ifTrue: [^self].	ctrl := self keyboardProcessor focusedEventHandler.	ctrl ~= self ifTrue: [self keyboardProcessor requestActivationFor: self].</body></methods><methods><class-id>Refactory.HotDraw.FigureTransitionTable</class-id> <category>accessing</category><body package="HotDraw Framework">goto: aState	^self		on: Figure 		goto: aState</body><body package="HotDraw Framework">nextStateForTool: aTool event: anEvent 	| class state |	class := (aTool figureAtEvent: anEvent) class.		[state := figureLookupStates at: class ifAbsent: [nil].	state notNil or: [class isNil]] 			whileFalse: [class := class superclass].	^state</body><body package="HotDraw Framework">on: figureClass goto: aToolState 	figureLookupStates at: figureClass put: aToolState</body></methods><methods><class-id>Refactory.HotDraw.FigureTransitionTable</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	figureLookupStates := Dictionary new</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	^isFilled 		ifTrue: [self graphic regionIntersects: (aPoint - 1 corner: aPoint + 1)]		ifFalse: [self graphic outlineIntersects: (aPoint - 1 corner: aPoint + 1)]</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation</class-id> <category>accessing</category><body package="HotDraw Framework">isFilled	^isFilled</body><body package="HotDraw Framework">isFilled: aBoolean 	isFilled := aBoolean.	self changed</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	positionSymbol := #stopPoint.	directionSymbol := #stopDirection.	isFilled := true</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation</class-id> <category>private</category><body package="HotDraw Framework">direction: aSymbol	directionSymbol := aSymbol</body><body package="HotDraw Framework">directionVector	^container perform: directionSymbol</body><body package="HotDraw Framework">graphic	^self subclassResponsibility</body><body package="HotDraw Framework">location	^container perform: positionSymbol</body><body package="HotDraw Framework">position: aSymbol	positionSymbol := aSymbol</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation</class-id> <category>displaying</category><body package="HotDraw Framework">displayOn: aGraphicsContext 	aGraphicsContext		lineWidth: container lineWidth;		paint: container lineColor.	isFilled 		ifTrue: [self graphic displayFilledOn: aGraphicsContext]		ifFalse: [self graphic displayStrokedOn: aGraphicsContext]</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation</class-id> <category>bounds accessing</category><body package="HotDraw Framework">bounds	^self graphic bounds</body></methods><methods><class-id>Refactory.HotDraw.LineAnnotation class</class-id> <category>instance creation</category><body package="HotDraw Framework">forStart	^(self new)		direction: #startDirection;		position: #startPoint;		yourself</body><body package="HotDraw Framework">forStop	^(self new)		direction: #stopDirection;		position: #stopPoint;		yourself</body></methods><methods><class-id>Refactory.HotDraw.ArrowAnnotation</class-id> <category>accessing</category><body package="HotDraw Framework">length	^length</body><body package="HotDraw Framework">length: aNumber 	length := aNumber.	self changed</body><body package="HotDraw Framework">width	^width</body><body package="HotDraw Framework">width: aNumber 	width := aNumber.	self changed</body></methods><methods><class-id>Refactory.HotDraw.ArrowAnnotation</class-id> <category>private</category><body package="HotDraw Framework">graphic	| vector u aPoint stopPoint points |	vector := self directionVector.	u := vector normal.	stopPoint := self location.	aPoint := stopPoint - (vector * length).	points := Array 				with: aPoint + (u * width)				with: stopPoint				with: aPoint - (u * width).	isFilled 		ifTrue: 			[points := points 						, (Array with: stopPoint - (vector * 0.8 * length) with: points first)].	^Polyline vertices: points</body></methods><methods><class-id>Refactory.HotDraw.ArrowAnnotation</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	width := 5.	length := 10</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>controller accessing</category><body package="HotDraw Framework">controller	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	^self getController</body><body package="HotDraw Framework">controller: aController 	"Set the receiver's controller to aController.  An instance of NoController can be	specified to indicate that the receiver will not have a controller.  The model of	aController is set to the receiver's model."	self setController: aController</body><body package="HotDraw Framework">defaultController	"Answer an initialized instance of the receiver's default controller.	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new</body><body package="HotDraw Framework">defaultControllerClass	^DrawingController</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>private</category><body package="HotDraw Framework">changedPreferredBounds: oldPreferredBounds forComponent: aVisualComponent 	| newBounds newRect |	newBounds := aVisualComponent bounds.	self 		updatePreferredBoundsWith: (newBounds origin corner: newBounds corner + 1).	"Rectangle draw differently on different platforms"	newRect := oldPreferredBounds isNil				ifTrue: [newBounds]				ifFalse: [oldPreferredBounds merge: newBounds].	newRect origin: newRect origin - 1.	newRect corner: newRect corner + 1.	self invalidateRectangle: newRect repairNow: false</body><body package="HotDraw Framework">getController	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	controller isNil ifTrue: [self setController: self defaultController].	^controller</body><body package="HotDraw Framework">privateSetController: aController	controller := aController</body><body package="HotDraw Framework">setComponents: aCollection	components := aCollection.	bounds := nil</body><body package="HotDraw Framework">setController: aController 	"Set the receiver's controller to aController. If aController is not nil, its view is set to the receiver 	and its model is set to the receiver's model."	aController notNil 		ifTrue: 			[aController view: self.			aController model: model].	controller := aController</body><body package="HotDraw Framework">updatePreferredBoundsWith: aRectangle 	| oldBounds |	oldBounds := bounds.	bounds := bounds isNil 				ifTrue: [aRectangle]				ifFalse: [bounds merge: aRectangle].	oldBounds = bounds ifFalse: [self changedPreferredBounds: oldBounds].	self invalidateRectangle: aRectangle repairNow: false</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>selection</category><body package="HotDraw Framework">clearSelections	selections notNil ifTrue: [selections do: [:each | each deselect]].	selections := OrderedCollection new.	handles do: 			[:each | 			each				invalidate;				container: nil].	handles := OrderedCollection new</body><body package="HotDraw Framework">deselectFigure: aFigure 	selections remove: aFigure ifAbsent: [^self].	aFigure deselect.	handles := handles reject: 					[:each | 					| value |					(value := each owner == aFigure) 						ifTrue: 							[each								invalidate;								container: nil].					value]</body><body package="HotDraw Framework">deselectFigures: aCollection 	aCollection		do: 			[:each | 			selections remove: each ifAbsent: [].			each deselect].	handles := handles				reject: 					[:each | 					| value |					(value := aCollection includes: each owner) 						ifTrue: [each invalidate; container: nil].					value]</body><body package="HotDraw Framework">isSelected: aFigure 	^aFigure isSelected</body><body package="HotDraw Framework">selectFigure: aFigure 	| newHandles |	aFigure isSelectable ifFalse: [^self].	aFigure select.	selections add: aFigure.	newHandles := aFigure handles.	handles addAll: newHandles.	newHandles do: 			[:each | 			self mergeBounds: each bounds.			each				container: self;				invalidate]</body><body package="HotDraw Framework">selection	^selections isEmpty 		ifTrue: [nil] 		ifFalse: [selections first]</body><body package="HotDraw Framework">selection: aFigure 	self clearSelections.	self selectFigure: aFigure</body><body package="HotDraw Framework">selections	^selections</body><body package="HotDraw Framework">selections: aCollection 	self clearSelections.	aCollection do: [:each | self selectFigure: each]</body><body package="HotDraw Framework">toggleSelection: aFigure 	(self isSelected: aFigure) 		ifTrue: [self deselectFigure: aFigure]		ifFalse: [self selectFigure: aFigure]</body><body package="HotDraw Framework">toggleSelections: aCollection 	aCollection do: [:each | self toggleSelection: each]</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>accessing</category><body package="HotDraw Framework">drawing	^self</body><body package="HotDraw Framework">edit	^DrawingEditor openOnDrawing: self</body><body package="HotDraw Framework">figureAt: aPoint 	"Drawings contain all points, if no figures contain this point, return self"	| figure |	handles size to: 1		by: -1		do: 			[:i | 			figure := (handles at: i) figureAt: aPoint.			figure notNil ifTrue: [^figure]].	components size to: 1		by: -1		do: 			[:i | 			figure := (components at: i) figureAt: aPoint.			figure notNil ifTrue: [^figure]].	^self</body><body package="HotDraw Framework">figures	^components copy</body><body package="HotDraw Framework">figuresIn: aRectangle 	^components select: [:each | aRectangle contains: each]</body><body package="HotDraw Framework">menuAt: aPoint 	| mb |	mb := MenuBuilder new.	mb		addCopyCutPaste;		line;		add: 'save...' -&gt; #saveDrawing;		add: 'load...' -&gt; #loadDrawing;		line;		add: 'print' -&gt; #print;		add: 'save as postscript...' -&gt; #savePostscript;		line;		add: 'inspect...' -&gt; #inspect;		line;		add: 'group' -&gt; #group;		add: 'ungroup' -&gt; #ungroup;		line.	self addLineColorMenuTo: mb.	self addFillColorMenuTo: mb.	self addLineWidthMenuTo: mb.	self addModelMenuTo: mb at: aPoint.	^mb menu</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>menu actions</category><body package="HotDraw Framework">copySelection	CopiedFigures := self selections collect: [:each | each copy]</body><body package="HotDraw Framework">cut	CopiedFigures := self selections copy.	self removeAll: self selections copy</body><body package="HotDraw Framework">group	| figures newFigure |	figures := selections copy.	figures isEmpty ifTrue: [^self].	self removeAll: figures.	newFigure := CompositeFigure new.	newFigure addAll: figures.	self		add: newFigure;		selection: newFigure</body><body package="HotDraw Framework">loadDrawing	| name boss drawing |	name := Dialog requestFileName: 'Load drawing from:'.	name isEmpty ifTrue: [^self].	name asFilename exists ifFalse: [^Dialog warn: 'File does not exist'].	boss := (#{BinaryObjectStorage} valueOrDo: [^self error: 'Cannot load; BOSS is not loaded']) 				onOld: name asFilename readStream.	drawing := Cursor read showWhile: [[boss next] ensure: [boss close]].	drawing		container: container;		model: model;		privateSetController: controller.	self oneWayBecome: drawing.	self invalidate</body><body package="HotDraw Framework">paste	CopiedFigures isNil ifTrue: [^self].	self addAll: (CopiedFigures collect: [:each | each copy])</body><body package="HotDraw Framework">print	| ps parent scale wrapper |	parent := container.	bounds := self computePreferredBounds expandedBy: 10 @ 10.	ps := Printer startPrintJobNamed: 'HotDraw.postscript'.	ps setLandscape: self extent x &gt; self extent y.	scale := (ps extent x / bounds extent x min: ps extent y / bounds extent y) 				min: 1.		[wrapper := (ScalingWrapper on: self) scale: scale.	self flushCaches.	(MockMedium 		on: wrapper		in: ps bounds		for: ps)		newGraphicsDevice: ps graphicsDevice;		display] 			ensure: 				[container := parent.				self flushCaches.				ps print]</body><body package="HotDraw Framework">saveDrawing	| name boss oldSelections |	name := Dialog requestFileName: 'Save drawing to:'.	name isEmpty ifTrue: [^self].	oldSelections := self selections.	self		clearSelections;		flushCaches.	boss := (#{BinaryObjectStorage} valueOrDo: [^self error: 'Cannot save; BOSS is not loaded']) onNew: name asFilename writeStream.	Cursor write showWhile: 			[[boss nextPut: self] ensure: 					[boss close.					self selections: oldSelections]]</body><body package="HotDraw Framework">savePostscript	| scale filename file gc drawingBounds |	filename := Dialog request: 'Enter filename for output:'				initialAnswer: 'drawing.ps'.	filename isEmpty ifTrue: [^self].	drawingBounds := self computePreferredBounds expandedBy: 10 @ 10.	file := PostScriptFile named: filename.	file setLandscape: drawingBounds extent x &gt; drawingBounds extent y.	gc := file graphicsContext.	scale := gc clippingBounds extent x / drawingBounds extent x 				min: gc clippingBounds extent y / drawingBounds extent y.	gc scaleBy: (scale min: 1).	self flushCaches.	self displayOn: gc.	file close</body><body package="HotDraw Framework">ungroup	| figures compositeFigures |	compositeFigures := selections select: [:each | each isComposite].	compositeFigures isEmpty ifTrue: [^self].	figures := OrderedCollection new.	compositeFigures do: [:each | figures addAll: each components].	self		removeAll: compositeFigures;		addAll: figures;		selections: figures</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>displaying</category><body package="HotDraw Framework">displayOn: aGraphicsContext 	| clipRect |	clipRect := aGraphicsContext clippingBounds.	aGraphicsContext paint: self backgroundColor.	clipRect displayFilledOn: aGraphicsContext.	super displayOn: aGraphicsContext.	handles do: 			[:each | 			(each intersects: clipRect) 				ifTrue: [each displayOn: aGraphicsContext copy]]</body><body package="HotDraw Framework">invalidateRectangle: aRectangle repairNow: aBoolean 	"Hacked to avoid some off by one errors. Different OS's have different definitions of how to draw 	rectangles. Instead of trying to do something smart, just expand the rectangle..."	^super invalidateRectangle: (aRectangle expandedBy: 1 @ 1) repairNow: aBoolean</body><body package="HotDraw Framework">invalidateRectangle: aRectangle repairNow: aBoolean forComponent: aFigure 	"Hacked to avoid some off by one errors. Different OS's have different definitions of how to draw 	rectangles. Instead of trying to do something smart, just expand the rectangle..."	^super 		invalidateRectangle: (aRectangle expandedBy: 1 @ 1)		repairNow: aBoolean		forComponent: aFigure</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	"Drawings contain everything"	^true</body><body package="HotDraw Framework">isDrawing	^true</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>broadcast</category><body package="HotDraw Framework">downcastEvent: aKey with: aParameter from: anInitiator 	"This is a message passed down the view structure to all subparts."	super 		downcastEvent: aKey		with: aParameter		from: anInitiator.	handles do: 			[:each | 			each 				downcastEvent: aKey				with: aParameter				from: anInitiator]</body><body package="HotDraw Framework">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	handles size to: 1		by: -1		do: 			[:i | 			((handles at: i) 				downcastLocalEvent: aKey				with: aParameter				at: aPoint				from: anInitiator) ifTrue: [^true]].	^super 		downcastLocalEvent: aKey		with: aParameter		at: aPoint		from: anInitiator</body><body package="HotDraw Framework">flushCoordinateCaches	"Flush caches that relate to coordinate translations between this component 	and its container"	super flushCoordinateCaches.	handles do: [:each | each flushCoordinateCaches]</body><body package="HotDraw Framework">newGraphicsDevice: aGraphicsDevice 	"Forward the newGraphicsDevice: aGraphicsDevice messages	to the receiver's components."	super newGraphicsDevice: aGraphicsDevice.	handles do: [:component | component newGraphicsDevice: aGraphicsDevice]</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>control</category><body package="HotDraw Framework">componentWantingControl	"Answer the first component that wishes to take control.  Answer nil if there is	no component wanting control."	| obj |	handles size to: 1		by: -1		do: 			[:i | 			obj := (handles at: i) objectWantingControl.			obj notNil ifTrue: [^obj]].	^super componentWantingControl</body><body package="HotDraw Framework">objectWantingControl	"The receiver is in a control hierarchy and the container is asking	for an object that wants control.  If no control is desired then the receiver	answers nil.  If control is wanted then the receiver answers the	control object."	| obj |	obj := super objectWantingControl.	obj notNil ifTrue: [^obj].	^self componentWantingControl</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>removing</category><body package="HotDraw Framework">remove: aFigure 	aFigure isRemoveable ifFalse: [^self].	self deselectFigure: aFigure.	super remove: aFigure.	^aFigure</body><body package="HotDraw Framework">removeAll: aCollection 	| toRemove |	toRemove := aCollection select: [:each | each isRemoveable].	self deselectFigures: toRemove.	super removeAll: toRemove.	^toRemove</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	selections := OrderedCollection new.	handles := OrderedCollection new.	self		lineWidth: 1;	"Set the default properties of figures, someone must do this..."		lineColor: ColorValue black;		fillColor: ColorValue white;		selectable: false;		moveable: false;		removeable: false;		connectable: false</body><body package="HotDraw Framework">release	Cursor normal show.	super release</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>event driven</category><body package="HotDraw Framework">handlerForMouseEvent: aMouseEvent 	"The receiver is in a control hierarchy and the container is asking 	for an object that wants control. If no control is desired then the 	receiver answers nil. If control is wanted then the receiver answers the 	control object."	self controller currentTool passInputDown 		ifTrue: 			[| obj |			components size to: 1				by: -1				do: 					[:i | 					obj := (components at: i) handlerForMouseEvent: aMouseEvent.					obj notNil ifTrue: [^obj]].			^super handlerForMouseEvent: aMouseEvent]		ifFalse: [^self controller]</body><body package="HotDraw Framework">updateSpot: type 	"Forward this message to all components."	components do: [:cmp | cmp updateSpot: type]</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>fileIn/Out</category><body package="HotDraw Framework">representBinaryOn: binWriter 	"Don't try to store our whole representation (just store our figures)."	^MessageSend 		receiver: self class		selector: #figures:		argument: components</body></methods><methods><class-id>Refactory.HotDraw.Drawing</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	selections := nil.	handles := #().	controller := nil</body></methods><methods><class-id>Refactory.HotDraw.Drawing class</class-id> <category>accessing</category><body package="HotDraw Framework">clearCutBuffer	CopiedFigures := nil</body></methods><methods><class-id>Refactory.HotDraw.Drawing class</class-id> <category>parcel load/unload/save</category><body package="HotDraw Framework">postLoadActionFor: aParcel	| comment |	comment := aParcel comment.	comment := comment					copyFrom: (comment indexOfSubCollection: 'SUMMARY' startingAt: 1) + 9					to: comment size.	(ComposedTextView			createOn: (TextCollector with: comment)			label: 'HotDraw Installation Workspace'			icon: (Icon constantNamed: #workspace))		openIn: (30@250 extent: 500@260)	"self postLoadActionFor: (Parcel parcelNamed: 'HotDraw Framework')"</body></methods><methods><class-id>Refactory.HotDraw.Drawing class</class-id> <category>private</category><body package="HotDraw Framework">figures: aCollection 	^(self new)		setComponents: aCollection;		yourself</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor</class-id> <category>accessing</category><body package="HotDraw Framework">drawing	drawing isNil 		ifTrue: 			[drawing := self buildDrawing.			self initializeDrawingController].	^drawing</body><body package="HotDraw Framework">toolbar	^ToolbarView model: self toolbarButtons</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor</class-id> <category>drawing description</category><body package="HotDraw Framework">activeToolNames	"Return the tool names that should pass input down to their views. Override to include more/less tools."	^#('Selection Tool')</body><body package="HotDraw Framework">drawingClass	"What type of drawing should we create?"	^Drawing</body><body package="HotDraw Framework">iconNames	"If the icon names don't follow the convention of removing white space from the tool name, 	making the first letter lowercase, and then replacing 'Tool' with 'Icon'; you might need to 	override this.	Normally the icon names can be converted from the tool names:		Selection Tool -&gt; selectionIcon		Bring To Front Tool -&gt; bringToFrontIcon"	^self toolNames collect: [:each | self iconNameFor: each]</body><body package="HotDraw Framework">toolNames	"Return the list of names for the tools. 'nil' represents a space between tools in the icon bar."	^#('Selection Tool' 	'Hand Tool'	nil 	'Delete Tool' 	'Bring To Front Tool' 	'Send To Back Tool' 	nil 	'Polyline Tool' 	'Bezier Tool' 	'Spline Tool' 	'Rectangle Tool' 	'Rounded Rectangle Tool'	'Ellipse Tool' 	'Arc Tool'	'Image Tool'	'Text Figure Creation Tool')</body><body package="HotDraw Framework">windowName	"What should our window label be?"	^'Drawing Editor'</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor</class-id> <category>interface opening</category><body package="HotDraw Framework">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	builder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	builder window model == self 		ifTrue: [builder window label: self windowName]</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor</class-id> <category>private</category><body package="HotDraw Framework">buildButtonDescriptionForTool: aString andIcon: iconSymbol 	| tool icon |	tool := Tool toolFor: aString.	tool passInputDown: (self activeToolNames includes: aString).	icon := (self class respondsTo: iconSymbol) 				ifTrue: [self class perform: iconSymbol]				ifFalse: [self class selectionIcon].	^ButtonDescription icon: icon value: tool</body><body package="HotDraw Framework">buildDrawing	drawing := self drawingClass new.	drawing model: self.	^drawing</body><body package="HotDraw Framework">drawing: aDrawing 	drawing := aDrawing.	self initializeDrawingController</body><body package="HotDraw Framework">iconNameFor: aString 	| iconName |	aString isNil ifTrue: [^nil].	iconName := aString select: [:each | each isAlphaNumeric].	iconName := iconName copyFrom: 1 to: (iconName size - 4 max: 1).	iconName at: 1 put: iconName first asLowercase.	^(iconName , 'Icon') asSymbol</body><body package="HotDraw Framework">toolbarButtons	buttons isNil 		ifTrue: 			[| list |			list := List new.			self toolNames with: self iconNames				do: 					[:tool :icon | 					list add: (tool isNil 								ifTrue: [ButtonDescription spacer]								ifFalse: [self buildButtonDescriptionForTool: tool andIcon: icon])].			buttons := SelectionInList new.			buttons list: list.			buttons selection: list first].	^buttons</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor</class-id> <category>initialize-release</category><body package="HotDraw Framework">initializeDrawingController	drawing controller tool: (BlockValue block: [:selection | selection value]				arguments: (Array with: self toolbarButtons selectionHolder))</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor class</class-id> <category>resources</category><body package="HotDraw Framework">arcIcon	^OpaqueImage figure: self arcIconImage shape: self arcIconMask</body><body package="HotDraw Framework">bezierIcon	^OpaqueImage figure: self bezierIconImage shape: self bezierIconMask</body><body package="HotDraw Framework">bringToFrontIcon	^OpaqueImage figure: self bringToFrontIconImage shape: self bringToFrontIconMask</body><body package="HotDraw Framework">deleteIcon	^OpaqueImage figure: self deleteIconImage shape: self deleteIconMask</body><body package="HotDraw Framework">ellipseIcon	^OpaqueImage figure: self ellipseIconImage shape: self ellipseIconMask</body><body package="HotDraw Framework">handIcon	^OpaqueImage figure: self handIconImage shape: self handIconMask</body><body package="HotDraw Framework">imageIcon	^OpaqueImage figure: self imageIconImage shape: self imageIconMask</body><body package="HotDraw Framework">polylineIcon	^OpaqueImage figure: self polylineIconImage shape: self polylineIconMask</body><body package="HotDraw Framework">rectangleIcon	^OpaqueImage figure: self rectangleIconImage shape: self rectangleIconMask</body><body package="HotDraw Framework">roundedRectangleIcon	^OpaqueImage figure: self roundedRectangleIconImage shape: self roundedRectangleIconMask</body><body package="HotDraw Framework">selectionIcon	^OpaqueImage figure: self selectionIconImage shape: self selectionIconMask</body><body package="HotDraw Framework">sendToBackIcon	^OpaqueImage figure: self sendToBackIconImage shape: self sendToBackIconMask</body><body package="HotDraw Framework">splineIcon	^OpaqueImage figure: self splineIconImage shape: self splineIconMask</body><body package="HotDraw Framework">textFigureCreationIcon	^OpaqueImage figure: self textFigureCreationImage		shape: self textFigureCreationMask</body><body package="HotDraw Framework">textIcon	^OpaqueImage figure: self textFigureCreationImage shape: self textMask</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor class</class-id> <category>examples</category><body package="HotDraw Framework">example1	"Open a drawing editor with another drawing inside."	"self example1"	| editor |	editor := self new.	editor open.	editor drawing add: (ViewAdapterFigure 				view: (DrawingEditor new allButOpenInterface: #windowSpec) window component				in: (10 @ 10 corner: 450 @ 350))</body><body package="HotDraw Framework">example2	"Open a drawing editor with a browser inside."	"self example2"	| editor |	editor := self new.	editor open.	editor drawing add: (ViewAdapterFigure 				view: (FileBrowser new allButOpenInterface: #windowSpec) window component				in: (10 @ 10 corner: 450 @ 350))</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor class</class-id> <category>interface opening</category><body package="HotDraw Framework">openOnDrawing: aDrawing	| editor |	editor := self new.	editor drawing: aDrawing.	editor open</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	^self isOpaque		ifTrue: 			[self asGeometric regionIntersects: (aPoint - 3 - (self lineWidth // 2)						corner: aPoint + 3 + (self lineWidth // 2))]		ifFalse: 			[self asGeometric outlineIntersects: (aPoint - 3 - (self lineWidth // 2)						corner: aPoint + 3 + (self lineWidth // 2))]</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>accessing</category><body package="HotDraw Framework">centerOfSegment: anIndex 	^((points at: anIndex) + (points at: anIndex + 1)) // 2</body><body package="HotDraw Framework">handles	| handles |	handles := OrderedCollection new.	1 to: points size - 1		do: 			[:i | 			handles 				add: ((i == 1 ifTrue: [TrackHandle] ifFalse: [IndexedTrackHandle]) 						pointAtIndex: i						of: self).			handles add: (TentativePositionHandle forSegment: i of: self)].	handles add: (TrackHandle pointAtIndex: points size of: self).	^handles</body><body package="HotDraw Framework">pointAt: anIndex 	^points at: anIndex</body><body package="HotDraw Framework">pointAt: anIndex put: aValue 	| oldBounds |	oldBounds := self preferredBounds.	points at: anIndex put: aValue.	bounds := self computePreferredBounds.	self changedPreferredBounds: oldBounds.	anIndex == 1 ifTrue: [^self changed: #startPoint].	anIndex == points size ifTrue: [^self changed: #stopPoint].	self changed</body><body package="HotDraw Framework">pointsSize	^points size</body><body package="HotDraw Framework">startPoint	^points first</body><body package="HotDraw Framework">startPoint: aPoint 	self pointAt: 1 put: aPoint</body><body package="HotDraw Framework">stopPoint	^points last</body><body package="HotDraw Framework">stopPoint: aPoint 	self pointAt: points size put: aPoint</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	points := #()</body><body package="HotDraw Framework">points: aCollection 	points := aCollection asOrderedCollection</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>converting</category><body package="HotDraw Framework">asGeometric	^Polyline vertices: points</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>removing</category><body package="HotDraw Framework">removePointAtIndex: aPosition 	| isSelected |	(isSelected := self isSelected) 		ifTrue: [self drawing deselectFigure: self].	points size &gt; 2 ifFalse: [^self].	points removeAtIndex: aPosition.	self recomputePreferredBounds.	isSelected ifTrue: [self drawing selectFigure: self]</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>transforming</category><body package="HotDraw Framework">basicTranslateBy: aPoint 	points := points collect: [:each | each + aPoint]</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	| geometric |	geometric := self asGeometric.	self isOpaque ifTrue: 			[aGraphicsContext paint: self fillColor.			geometric displayFilledOn: aGraphicsContext].	self lineWidth &gt; 0 ifTrue: 			[aGraphicsContext lineWidth: self lineWidth.			aGraphicsContext paint: self lineColor.			geometric displayStrokedOn: aGraphicsContext]</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>adding</category><body package="HotDraw Framework">addPoint: aPoint 	points add: aPoint.	self updatePreferredBoundsWith: aPoint.	^aPoint</body><body package="HotDraw Framework">addPoint: aPoint beforeIndex: aPosition 	points add: aPoint beforeIndex: aPosition.	self updatePreferredBoundsWith: aPoint.	^aPoint</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	points := points copy</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>changing</category><body package="HotDraw Framework">deletionUpdateFrom: aFigure 	"Since we're probably connected to the figure that was deleted, remove ourself"	super deletionUpdateFrom: aFigure.	self drawing notNil ifTrue: [self drawing remove: self]</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>bounds accessing</category><body package="HotDraw Framework">computePreferredBounds	| rect |	rect := points inject: (points first extent: 0 @ 0)				into: 					[:sum :point | 					sum						origin: (sum origin min: point);						corner: (sum corner max: point)].	rect corner: rect corner + (self lineWidth // 2) + 1.	"Add one, so we get the horizontal/vertical lines"	rect origin: rect origin - (self lineWidth // 2).	^rect</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure</class-id> <category>private</category><body package="HotDraw Framework">updatePreferredBoundsWith: aPoint 	| oldBounds |	oldBounds := self preferredBounds.	bounds := (oldBounds origin min: aPoint) corner: (oldBounds corner max: aPoint).	oldBounds ~= bounds ifTrue: [self changedPreferredBounds: oldBounds]</body></methods><methods><class-id>Refactory.HotDraw.PolylineFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">connect: aFigure to: anotherFigure 	| figure |	figure := self withPoints: (Array with: aFigure center with: anotherFigure center).	aFigure addDependent: figure.	anotherFigure addDependent: figure.	^figure</body><body package="HotDraw Framework">createAt: aPoint	^self withPoints: (Array with: aPoint with: aPoint)</body><body package="HotDraw Framework">start: aPoint stop: anotherPoint 	^self withPoints: (Array with: aPoint with: anotherPoint)</body><body package="HotDraw Framework">withPoints: aCollection	^self new points: aCollection</body></methods><methods><class-id>Refactory.HotDraw.SplineFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	spline := nil</body></methods><methods><class-id>Refactory.HotDraw.SplineFigure</class-id> <category>private</category><body package="HotDraw Framework">asGeometric	^self spline</body><body package="HotDraw Framework">computePreferredBounds	| rect |	rect := self spline bounds.	^rect origin - (self lineWidth // 2) 		corner: rect corner + (self lineWidth // 2) + 1</body><body package="HotDraw Framework">computeSpline	^Spline controlPoints: points asArray</body><body package="HotDraw Framework">spline	^spline isNil		ifTrue: [spline := self computeSpline] 		ifFalse: [spline]</body></methods><methods><class-id>Refactory.HotDraw.SplineFigure</class-id> <category>transforming</category><body package="HotDraw Framework">basicTranslateBy: aPoint 	super basicTranslateBy: aPoint.	spline := spline translatedBy: aPoint</body></methods><methods><class-id>Refactory.HotDraw.SplineFigure</class-id> <category>accessing</category><body package="HotDraw Framework">pointAt: anIndex put: aValue 	super pointAt: anIndex put: aValue.	spline := nil</body></methods><methods><class-id>Refactory.HotDraw.DiamondAnnotation</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	isFilled := false</body></methods><methods><class-id>Refactory.HotDraw.DiamondAnnotation</class-id> <category>private</category><body package="HotDraw Framework">graphic	| vector u aPoint stopPoint points |	vector := self directionVector.	u := vector normal.	stopPoint := self location.	aPoint := stopPoint - (vector * length).	points := (Array new: 5)				at: 1 put: stopPoint;				at: 2 put: aPoint - (u * width);				at: 3 put: stopPoint - (vector * 2 * length);				at: 4 put: aPoint + (u * width);				at: 5 put: stopPoint;				yourself.	^Polyline vertices: points</body></methods><methods><class-id>Refactory.HotDraw.DiamondAnnotation</class-id> <category>displaying</category><body package="HotDraw Framework">displayOn: aGraphicsContext 	isFilled ifTrue: [^super displayOn: aGraphicsContext].	aGraphicsContext		lineWidth: container lineWidth;		paint: container fillColor.	self graphic displayFilledOn: aGraphicsContext.	aGraphicsContext paint: container lineColor.	self graphic displayStrokedOn: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.CharacterTransitionTable</class-id> <category>accessing</category><body package="HotDraw Framework">forCharacters: characterCollection goto: aToolState 	characterMap add: characterCollection -&gt; aToolState</body><body package="HotDraw Framework">goto: aState 	self		forCharacters: ((0 to: 255) collect: [:each | Character value: each])		goto: aState</body><body package="HotDraw Framework">nextStateForTool: aTool event: anEvent 	anEvent isKeyboard ifFalse: [^nil].	1 to: characterMap size		do: 			[:i | 			| each |			each := characterMap at: i.			(each key includes: anEvent keyValue) ifTrue: [^each value]].	^nil</body></methods><methods><class-id>Refactory.HotDraw.CharacterTransitionTable</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	characterMap := OrderedCollection new</body></methods><methods><class-id>Refactory.HotDraw.BezierFigure</class-id> <category>transforming</category><body package="HotDraw Framework">basicTranslateBy: aPoint 	super basicTranslateBy: aPoint.	bezier := bezier translatedBy: aPoint</body></methods><methods><class-id>Refactory.HotDraw.BezierFigure</class-id> <category>accessing</category><body package="HotDraw Framework">handles	^(1 to: points size) collect: [:i | TrackHandle pointAtIndex: i of: self]</body><body package="HotDraw Framework">pointAt: anIndex put: aValue 	super pointAt: anIndex put: aValue.	bezier := nil</body></methods><methods><class-id>Refactory.HotDraw.BezierFigure</class-id> <category>copying</category><body package="HotDraw Framework">postCopy	super postCopy.	bezier := nil</body></methods><methods><class-id>Refactory.HotDraw.BezierFigure</class-id> <category>private</category><body package="HotDraw Framework">asGeometric	^self bezier</body><body package="HotDraw Framework">bezier	^bezier isNil 		ifTrue: [bezier := self computeBezier] 		ifFalse: [bezier]</body><body package="HotDraw Framework">computeBezier	^Bezier 		start: points first		end: points last		controlPoint1: (points at: 2)		controlPoint2: (points at: 3)</body><body package="HotDraw Framework">computePreferredBounds	| rect |	rect := self bezier bounds.	^rect origin - (self lineWidth // 2) 		corner: rect corner + (self lineWidth // 2)</body></methods><methods><class-id>Refactory.HotDraw.BezierFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">createAt: aPoint 	^self start: aPoint stop: aPoint</body><body package="HotDraw Framework">start: startPoint stop: stopPoint 	| diff |	diff := stopPoint - startPoint.	^self withPoints: (Array 				with: startPoint				with: diff / 3.0 + startPoint				with: diff * 2 / 3.0 + startPoint				with: stopPoint)</body></methods><methods><class-id>Refactory.HotDraw.LineFigure</class-id> <category>accessing</category><body package="HotDraw Framework">addAnnotation: aLineAnnotation 	annotations := annotations copyWith: aLineAnnotation.	aLineAnnotation container: self.	self recomputePreferredBounds</body><body package="HotDraw Framework">addStartArrow	^self addAnnotation: ArrowAnnotation forStart</body><body package="HotDraw Framework">addStopArrow	^self addAnnotation: ArrowAnnotation forStop</body><body package="HotDraw Framework">menuAt: aPoint 	| menu submenu selectedAnnotation |	submenu := MenuBuilder new.	LineAnnotation allSubclasses do: 			[:each | 			| name |			name := each name asString.			(name copyFrom: (name size - 9 max: 1) to: name size) = 'Annotation' 				ifTrue: [name := name copyFrom: 1 to: name size - 10].			submenu				add: ('Start ' , name) -&gt; [self addAnnotation: each forStart];				add: ('Stop ' , name) -&gt; [self addAnnotation: each forStop]].	selectedAnnotation := annotations 				detect: [:each | each containsPoint: aPoint]				ifNone: [nil].	selectedAnnotation notNil 		ifTrue: 			[submenu				line;				add: 'Remove annotation' -&gt; [self removeAnnotation: selectedAnnotation]].	menu := super menuAt: aPoint.	menu addItem: ((MenuItem labeled: 'Annotations') submenu: submenu menu).	^menu</body><body package="HotDraw Framework">removeAnnotation: aLineAnnotation 	annotations := annotations copyWithout: aLineAnnotation.	aLineAnnotation container: nil.	self recomputePreferredBounds</body><body package="HotDraw Framework">startDirection	| direction |	direction := points first - (points at: 2).	^direction = (0 @ 0) 		ifTrue: [1 @ 0] 		ifFalse: [direction unitVector]</body><body package="HotDraw Framework">stopDirection	| direction |	direction := points last - (points at: points size - 1).	^direction = (0 @ 0) 		ifTrue: [1 @ 0] 		ifFalse: [direction unitVector]</body></methods><methods><class-id>Refactory.HotDraw.LineFigure</class-id> <category>private</category><body package="HotDraw Framework">computePreferredBounds	^annotations inject: super computePreferredBounds		into: [:sum :each | sum merge: each bounds]</body></methods><methods><class-id>Refactory.HotDraw.LineFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	annotations := #()</body></methods><methods><class-id>Refactory.HotDraw.LineFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayOn: aGraphicsContext 	super displayOn: aGraphicsContext.	annotations do: [:each | each displayOn: aGraphicsContext]</body></methods><methods><class-id>Refactory.HotDraw.LineFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">connect: aFigure to: anotherFigure 	| figure |	figure := super connect: aFigure to: anotherFigure.	figure addDependent: aFigure.	figure addDependent: anotherFigure.	figure addStopArrow.	^figure</body></methods><methods><class-id>Refactory.HotDraw.CircleAnnotation</class-id> <category>private</category><body package="HotDraw Framework">graphic	| center origin |	origin := self location.	center := origin - (self directionVector * radius).	^EllipticalArc 		boundingBox: (center - radius corner: center + radius + 1)</body></methods><methods><class-id>Refactory.HotDraw.CircleAnnotation</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	super initialize.	radius := 4</body></methods><methods><class-id>Refactory.HotDraw.CircleAnnotation</class-id> <category>accessing</category><body package="HotDraw Framework">radius	^radius</body><body package="HotDraw Framework">radius: aNumber 	radius := aNumber.	self changed</body></methods><methods><class-id>Refactory.HotDraw.ToolState</class-id> <category>testing</category><body package="HotDraw Framework">isEndState	^false</body></methods><methods><class-id>Refactory.HotDraw.ToolState</class-id> <category>events</category><body package="HotDraw Framework">blueButtonPressedEvent: aMouseButtonEvent 	^nil</body><body package="HotDraw Framework">blueButtonReleasedEvent: aMouseButtonEvent 	^nil</body><body package="HotDraw Framework">boundsEvent: anEvent	^nil</body><body package="HotDraw Framework">closeEvent: aCloseEvent	^nil</body><body package="HotDraw Framework">doubleClickEvent: anEvent 	^doubleClick</body><body package="HotDraw Framework">enterEvent: anEvent	^nil</body><body package="HotDraw Framework">exitEvent: anEvent 	"Treat exiting a drawing as releasing the red button."	^redButtonRelease</body><body package="HotDraw Framework">expandEvent: anEvent	^nil</body><body package="HotDraw Framework">exposeEvent: anEvent	^nil</body><body package="HotDraw Framework">immediateEvent: anEvent	^immediate</body><body package="HotDraw Framework">keyPressedEvent: anEvent	^keyPress</body><body package="HotDraw Framework">keyReleasedEvent: anEvent	^keyRelease</body><body package="HotDraw Framework">mouseMovedEvent: aMouseMovedEvent 	^mouseMove</body><body package="HotDraw Framework">mouseWheelEvent: anEvent	^nil</body><body package="HotDraw Framework">moveEvent: aMoveEvent	^nil</body><body package="HotDraw Framework">prefocusKeypressEvent: ignored	^nil</body><body package="HotDraw Framework">pseudoEvent: aPseudoEvent	^nil</body><body package="HotDraw Framework">redButtonPressedEvent: aMouseButtonEvent 	^redButtonPress</body><body package="HotDraw Framework">redButtonReleasedEvent: aMouseButtonEvent 	^redButtonRelease</body><body package="HotDraw Framework">resizeEvent: anEvent	^nil</body><body package="HotDraw Framework">unknownEvent: anEvent	^nil</body><body package="HotDraw Framework">windowEnterEvent: anEvent	^nil</body><body package="HotDraw Framework">windowExitEvent: anEvent	^nil</body><body package="HotDraw Framework">yellowButtonPressedEvent: aMouseButtonEvent 	^yellowButtonPress</body><body package="HotDraw Framework">yellowButtonReleasedEvent: aMouseButtonEvent 	^yellowButtonRelease</body></methods><methods><class-id>Refactory.HotDraw.ToolState</class-id> <category>accessing</category><body package="HotDraw Framework">doubleClick	^doubleClick</body><body package="HotDraw Framework">doubleClick: aTransitionTable 	doubleClick := aTransitionTable</body><body package="HotDraw Framework">immediate	^immediate</body><body package="HotDraw Framework">immediate: aTransitionTable 	immediate := aTransitionTable</body><body package="HotDraw Framework">keyPress	^keyPress</body><body package="HotDraw Framework">keyPress: aTransitionTable 	keyPress := aTransitionTable</body><body package="HotDraw Framework">keyRelease	^keyRelease</body><body package="HotDraw Framework">keyRelease: aTransitionTable 	keyRelease := aTransitionTable</body><body package="HotDraw Framework">mouseMove	^mouseMove</body><body package="HotDraw Framework">mouseMove: aTransitionTable 	mouseMove := aTransitionTable</body><body package="HotDraw Framework">name	^name isNil 		ifTrue: [self identityHash printString] 		ifFalse: [name]</body><body package="HotDraw Framework">redButtonPress	^redButtonPress</body><body package="HotDraw Framework">redButtonPress: aTransitionTable 	redButtonPress := aTransitionTable</body><body package="HotDraw Framework">redButtonRelease	^redButtonRelease</body><body package="HotDraw Framework">redButtonRelease: aTransitionTable 	redButtonRelease := aTransitionTable</body><body package="HotDraw Framework">yellowButtonPress	^yellowButtonPress</body><body package="HotDraw Framework">yellowButtonPress: aTransitionTable 	yellowButtonPress := aTransitionTable</body><body package="HotDraw Framework">yellowButtonRelease	^yellowButtonRelease</body><body package="HotDraw Framework">yellowButtonRelease: aTransitionTable 	yellowButtonRelease := aTransitionTable</body></methods><methods><class-id>Refactory.HotDraw.ToolState</class-id> <category>tool-accessing</category><body package="HotDraw Framework">immediateStateForEvent: anEvent tool: aTool 	| transitionTable |	transitionTable := self immediateEvent: anEvent.	transitionTable isNil ifTrue: [^nil].	^transitionTable nextStateForTool: aTool event: anEvent</body><body package="HotDraw Framework">nextStateForEvent: anEvent tool: aTool 	| transitionTable |	transitionTable := anEvent dispatchTo: self.	transitionTable isNil ifTrue: [^nil].	^transitionTable nextStateForTool: aTool event: anEvent</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>accessing</category><body package="HotDraw Framework">controller	^controller</body><body package="HotDraw Framework">controller: aController	controller := aController</body><body package="HotDraw Framework">cursor	^cursor</body><body package="HotDraw Framework">cursor: aCursor 	cursor := aCursor.	cursor show</body><body package="HotDraw Framework">cursorPointFor: anEvent 	| point |	point := self primCursorPointFor: anEvent.	^Grid isNil 		ifTrue: [point]		ifFalse: [point // Grid * Grid]</body><body package="HotDraw Framework">drawing	^controller view</body><body package="HotDraw Framework">figureAtEvent: anEvent 	^figure isNil		ifTrue: [figure := self drawing figureAt: (self primCursorPointFor: anEvent)]		ifFalse: [figure]</body><body package="HotDraw Framework">figureUnderCursor	^self drawing figureAt: self sensor cursorPoint</body><body package="HotDraw Framework">graphicsContext	^self drawing graphicsContext</body><body package="HotDraw Framework">initialState	^initialState</body><body package="HotDraw Framework">sensor	^controller sensor</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>controller accessing</category><body package="HotDraw Framework">passInputDown: aBoolean 	passInputDown := aBoolean</body><body package="HotDraw Framework">selected	"The current tool has just been selected, evaluate the first state"	self changeToState: initialState event: nil</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>initialize-release</category><body package="HotDraw Framework">initialize	passInputDown := true.	data := Dictionary new.	cursor := Cursor normal</body><body package="HotDraw Framework">startState: aState 	initialState := aState.	self changeToState: initialState event: nil</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>variable accessing</category><body package="HotDraw Framework">valueAt: aSymbol 	^data at: aSymbol ifAbsent: [nil]</body><body package="HotDraw Framework">valueAt: aSymbol put: anObject	^data at: aSymbol put: anObject</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>events</category><body package="HotDraw Framework">changeToState: aToolState event: anEvent 	aToolState isNil ifTrue: [^self].	currentState := aToolState.	Debug ifTrue: [self printDebuggingInformation].	currentState == initialState ifTrue: [data := Dictionary new].	[currentState evaluateIn: self event: anEvent]		ifCurtailed: [currentState := initialState].	"Fail into the initialState"	currentState isEndState		ifTrue: [self changeToState: initialState event: anEvent]		ifFalse: 			[| newState |			newState := currentState immediateStateForEvent: anEvent tool: self.			newState notNil ifTrue: [self changeToState: newState event: anEvent]]</body><body package="HotDraw Framework">handleEvent: anEvent 	| nextState |	figure := nil.	nextState := currentState nextStateForEvent: anEvent tool: self.	self changeToState: nextState event: anEvent.	^nextState notNil</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>private</category><body package="HotDraw Framework">primCursorPointFor: anEvent 	^anEvent isMouseEvent 		ifTrue: [self sensor cursorPointFor: anEvent]		ifFalse: [self sensor cursorPoint]</body><body package="HotDraw Framework">printDebuggingInformation	Transcript		print: currentState;		cr;		flush</body></methods><methods><class-id>Refactory.HotDraw.Tool</class-id> <category>testing</category><body package="HotDraw Framework">isIdle	^currentState == initialState</body><body package="HotDraw Framework">passInputDown	^passInputDown and: [self isIdle]</body></methods><methods><class-id>Refactory.HotDraw.Tool class</class-id> <category>class initialization</category><body package="HotDraw Framework">initialize	"self initialize"	self initializeStates</body><body package="HotDraw Framework">initializeStates	| selectors |	selectors := self 				sortSelectors: (self class organization listAtCategoryNamed: #'tool states')				initial: Dictionary new.	States := Dictionary new.	selectors do: [:each | self perform: each].	States at: 'Hand Tool'		put: (States at: 'Selection Tool' ifAbsent: [EndToolState new])</body><body package="HotDraw Framework">reinitialize	"Tool reinitialize"	| oldStates |	oldStates := States.	[self initializeStates] ifCurtailed: [States := oldStates]</body><body package="HotDraw Framework">sortSelectors: selectors initial: aDictionary 	| runnable |	runnable := selectors select: 					[:each | 					States := aDictionary copy.					Dictionary keyNotFoundSignal handle: [:ex | ex returnWith: false]						do: 							[self perform: each.							true]].	runnable isEmpty 		ifTrue: [self error: 'Can''t initialize the tools, circular dependencies'].	^runnable size == selectors size 		ifTrue: [^selectors]		ifFalse: 			[States := aDictionary copy.			runnable do: [:each | self perform: each].			runnable 				, (self sortSelectors: (selectors asOrderedCollection removeAll: runnable; yourself) initial: States)]</body></methods><methods><class-id>Refactory.HotDraw.Tool class</class-id> <category>instance creation</category><body package="HotDraw Framework">new	^super new initialize</body><body package="HotDraw Framework">selectionTool	^self toolFor: 'Selection Tool'</body><body package="HotDraw Framework">toolFor: aString 	^(self new)		startState: (States at: aString);		yourself</body></methods><methods><class-id>Refactory.HotDraw.Tool class</class-id> <category>accessing</category><body package="HotDraw Framework">clearStates	States := nil</body><body package="HotDraw Framework">debug: aBoolean	"self debug: true"	"self debug: false"	Debug := aBoolean</body><body package="HotDraw Framework">grid: aPoint 	"self grid: 8 @ 8"	Grid := aPoint</body><body package="HotDraw Framework">stateFor: aString 	^States at: aString</body><body package="HotDraw Framework">states	^States</body></methods><methods><class-id>Refactory.HotDraw.Tool class</class-id> <category>tool states</category><body package="HotDraw Framework">initializeBezierTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'End bezier line'; instVarAt: 3 put: (Text string: '[:tool :event | | figure diff |figure := tool valueAt: #figure.diff := (figure pointAt: 4) - (figure pointAt: 1).figure pointAt: 2 put: diff / 3.0 + (figure pointAt: 1);		pointAt: 3 put: diff * 2 / 3.0 + (figure pointAt: 1)]' runs: (RunArray runs: #(229) values: #(nil))); instVarAt: 4 put: (Point x: 266 y: 345); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Bezier Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool cursor: Cursor crossHair]' runs: (RunArray runs: #(46) values: #(nil))); instVarAt: 4 put: (Point x: 225 y: 20); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Pressed Bezier Tool'; instVarAt: 3 put: (Text string: '[:tool :event | | figure point |point := tool cursorPointFor: event.figure := BezierFigure start: point stop: point.tool valueAt: #figure put: figure.tool drawing add: figure]' runs: (RunArray runs: #(180) values: #(nil))); instVarAt: 4 put: (Point x: 195 y: 121); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Move Bezier Tool'; instVarAt: 3 put: (Text string: '[:tool :event | (tool valueAt: #figure) stopPoint: (tool cursorPointFor: event)]' runs: (RunArray runs: #(81) values: #(nil))); instVarAt: 4 put: (Point x: 102 y: 218); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Cancel Figure Creation'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 310 y: 249); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 48 y: 99); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Bezier Tool'); to: (stateTable at: 'Pressed Bezier Tool'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 261 y: 51); add: (Point x: 258 y: 121); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Bezier Tool'); to: (stateTable at: 'End bezier line'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 174 y: 248); add: (Point x: 296 y: 346); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Pressed Bezier Tool'); to: (stateTable at: 'Move Bezier Tool'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 235 y: 151); add: (Point x: 171 y: 218); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Bezier Tool'); to: (stateTable at: 'Move Bezier Tool'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 102 y: 232); add: (Point x: 50 y: 249); add: (Point x: 45 y: 273); add: (Point x: 96 y: 273); add: (Point x: 132 y: 248); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Pressed Bezier Tool'); to: (stateTable at: 'Cancel Figure Creation'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 281 y: 151); add: (Point x: 368 y: 249); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Bezier Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 225 y: 36); add: (Point x: 82 y: 102); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'End bezier line' put: (EndToolState name: 'End bezier line' command: [:tool :event | | figure diff |figure := tool valueAt: #figure.diff := (figure pointAt: 4) - (figure pointAt: 1).figure pointAt: 2 put: diff / 3.0 + (figure pointAt: 1);		pointAt: 3 put: diff * 2 / 3.0 + (figure pointAt: 1)]).	Tool states at: 'Bezier Tool' put: (ToolState name: 'Bezier Tool' command: [:tool :event | tool cursor: Cursor crossHair]).	Tool states at: 'Pressed Bezier Tool' put: (ToolState name: 'Pressed Bezier Tool' command: [:tool :event | | figure point |point := tool cursorPointFor: event.figure := BezierFigure start: point stop: point.tool valueAt: #figure put: figure.tool drawing add: figure]).	Tool states at: 'Move Bezier Tool' put: (ToolState name: 'Move Bezier Tool' command: [:tool :event | (tool valueAt: #figure) stopPoint: (tool cursorPointFor: event)]).	(Tool stateFor: 'Move Bezier Tool') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'End bezier line'); yourself).	(Tool stateFor: 'Move Bezier Tool') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Bezier Tool'); yourself).	(Tool stateFor: 'Bezier Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Pressed Bezier Tool'); yourself).	(Tool stateFor: 'Bezier Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Pressed Bezier Tool') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Cancel Figure Creation'); yourself).	(Tool stateFor: 'Pressed Bezier Tool') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Bezier Tool'); yourself).</body><body package="HotDraw Framework">initializeBringToFrontTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Bring To Front Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool cursor: Cursor crossHair]' runs: (RunArray runs: #(46) values: #(nil))); instVarAt: 4 put: (Point x: 193 y: 47); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Bring To Front Press'; instVarAt: 3 put: (Text string: '[:tool :event | | figure |figure := tool figureAtEvent: event.(figure isHandle or: [figure isDrawing])	ifFalse: [tool drawing bringToFront: figure]]' runs: (RunArray runs: #(152) values: #(nil))); instVarAt: 4 put: (Point x: 192 y: 228); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 395 y: 165); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Bring To Front Tool'); to: (stateTable at: 'Bring To Front Press'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 253 y: 78); add: (Point x: 256 y: 228); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Bring To Front Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 283 y: 76); add: (Point x: 401 y: 168); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Bring To Front Tool' put: (ToolState name: 'Bring To Front Tool' command: [:tool :event | tool cursor: Cursor crossHair]).	Tool states at: 'Bring To Front Press' put: (EndToolState name: 'Bring To Front Press' command: [:tool :event | | figure |figure := tool figureAtEvent: event.(figure isHandle or: [figure isDrawing])	ifFalse: [tool drawing bringToFront: figure]]).	(Tool stateFor: 'Bring To Front Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Bring To Front Press'); yourself).	(Tool stateFor: 'Bring To Front Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).</body><body package="HotDraw Framework">initializeConnectionState	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Connection State'; instVarAt: 3 put: (Text string: '[:tool :event | | figure startPoint |figure := (tool figureAtEvent: event) owner.startPoint := tool cursorPointFor: event.tool valueAt: #figure put: figure;	valueAt: #startPoint put: startPoint;	valueAt: #lastPoint put: startPoint.(figure canConnectFromPoint: startPoint)	ifFalse: [tool changeToState: tool initialState event: event]]' runs: (RunArray runs: #(342) values: #(nil))); instVarAt: 4 put: (Point x: 74 y: 35); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Connection Drag'; instVarAt: 3 put: (Text string: '[:tool :event | | currentPoint origin |origin := tool valueAt: #startPoint.tool drawing	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.currentPoint := tool cursorPointFor: event.(LineSegment from: currentPoint to: origin)	displayStrokedOn: tool graphicsContext.tool valueAt: #lastPoint put: currentPoint]' runs: (RunArray runs: #(367) values: #(nil))); instVarAt: 4 put: (Point x: 239 y: 142); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'End Connection'; instVarAt: 3 put: '[:tool :event | | endFigure startFigure origin lastPoint |origin := tool valueAt: #startPoint.lastPoint := tool valueAt: #lastPoint.tool drawing	invalidateRectangle: 		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.endFigure := (tool figureAtEvent: event) owner.startFigure := tool valueAt: #figure.(startFigure canConnectFromPoint: origin				to: endFigure				at: lastPoint) ifTrue: 			[tool drawing add: (startFigure connectFromPoint: origin				to: endFigure				at: lastPoint)]]'; instVarAt: 4 put: (Point x: 68 y: 256); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Connection State'); to: (stateTable at: 'Connection Drag'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 154.898 y: 64.6094); add: (Point x: 268.109 y: 141.395); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Connection Drag'); to: (stateTable at: 'Connection Drag'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 337.937 y: 147.828); add: (Point x: 397 y: 137); add: (Point x: 393 y: 187); add: (Point x: 333.938 y: 168.297); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Connection Drag'); to: (stateTable at: 'End Connection'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 263.016 y: 171.672); add: (Point x: 138.977 y: 256.333); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Connection State'); to: (stateTable at: 'End Connection'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 126.969 y: 66.7422); add: (Point x: 119.031 y: 255.261); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Connection State' put: (ToolState name: 'Connection State' command: [:tool :event | | figure startPoint |figure := (tool figureAtEvent: event) owner.startPoint := tool cursorPointFor: event.tool valueAt: #figure put: figure;	valueAt: #startPoint put: startPoint;	valueAt: #lastPoint put: startPoint.(figure canConnectFromPoint: startPoint)	ifFalse: [tool changeToState: tool initialState event: event]]).	Tool states at: 'Connection Drag' put: (ToolState name: 'Connection Drag' command: [:tool :event | | currentPoint origin |origin := tool valueAt: #startPoint.tool drawing	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.currentPoint := tool cursorPointFor: event.(LineSegment from: currentPoint to: origin)	displayStrokedOn: tool graphicsContext.tool valueAt: #lastPoint put: currentPoint]).	Tool states at: 'End Connection' put: (EndToolState name: 'End Connection' command: [:tool :event | | endFigure startFigure origin lastPoint |origin := tool valueAt: #startPoint.lastPoint := tool valueAt: #lastPoint.tool drawing	invalidateRectangle: 		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.endFigure := (tool figureAtEvent: event) owner.startFigure := tool valueAt: #figure.(startFigure canConnectFromPoint: origin				to: endFigure				at: lastPoint) ifTrue: 			[tool drawing add: (startFigure connectFromPoint: origin				to: endFigure				at: lastPoint)]]).	(Tool stateFor: 'Connection Drag') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Connection Drag'); yourself).	(Tool stateFor: 'Connection Drag') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'End Connection'); yourself).	(Tool stateFor: 'Connection State') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Connection Drag'); yourself).	(Tool stateFor: 'Connection State') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'End Connection'); yourself).</body><body package="HotDraw Framework">initializeDeleteTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Delete Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool cursor: Cursor crossHair]' runs: (RunArray runs: #(46) values: #(nil))); instVarAt: 4 put: (Point x: 242 y: 63); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Delete Figure Under Cursor'; instVarAt: 3 put: (Text string: '[:tool :event | | figure |figure := tool figureAtEvent: event.(figure isHandle or: [figure isDrawing])	ifFalse: [tool drawing remove: figure]]' runs: (RunArray runs: #(146) values: #(nil))); instVarAt: 4 put: (Point x: 170 y: 224); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 370 y: 158); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Delete Tool'); to: (stateTable at: 'Delete Figure Under Cursor'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 275 y: 94); add: (Point x: 252 y: 224); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Delete Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 296 y: 92); add: (Point x: 376 y: 162); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Delete Tool' put: (ToolState name: 'Delete Tool' command: [:tool :event | tool cursor: Cursor crossHair]).	Tool states at: 'Delete Figure Under Cursor' put: (EndToolState name: 'Delete Figure Under Cursor' command: [:tool :event | | figure |figure := tool figureAtEvent: event.(figure isHandle or: [figure isDrawing])	ifFalse: [tool drawing remove: figure]]).	(Tool stateFor: 'Delete Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Delete Figure Under Cursor'); yourself).	(Tool stateFor: 'Delete Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).</body><body package="HotDraw Framework">initializeImageTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((Core.OrderedCollection new) add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Image Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool cursor: Cursor origin]' runs: (Core.RunArray runs: #(43) values: #(nil))); instVarAt: 4 put: (Core.Point x: 214 y: 50); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Wait for button release (Image Tool)'; instVarAt: 3 put: '[:tool :event | tool valueAt: #cursorPoint put: (tool cursorPointFor: event)]'; instVarAt: 4 put: (Core.Point x: 160 y: 188); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 382 y: 122); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Create ImageFigure'; instVarAt: 3 put: '[:tool :event | tool drawing add: (ImageFigure createAt: (tool valueAt: #cursorPoint))]'; instVarAt: 4 put: (Core.Point x: 198 y: 305); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Image Tool'); to: (stateTable at: 'Wait for button release (Image Tool)'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 249.0 y: 77.625); add: (Core.Point x: 257.62 y: 187.338); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Image Tool'); to: (stateTable at: 'Menu'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 271.781 y: 74.8125); add: (Core.Point x: 383.849 y: 127.414); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Wait for button release (Image Tool)'); to: (stateTable at: 'Create ImageFigure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 262.25 y: 215.875); add: (Core.Point x: 265.993 y: 304.408); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Image Tool' put: (ToolState name: 'Image Tool' command: [:tool :event | tool cursor: Cursor origin]).	Tool states at: 'Wait for button release (Image Tool)' put: (ToolState name: 'Wait for button release (Image Tool)' command: [:tool :event | tool valueAt: #cursorPoint put: (tool cursorPointFor: event)]).	Tool states at: 'Create ImageFigure' put: (EndToolState name: 'Create ImageFigure' command: [:tool :event | tool drawing add: (ImageFigure createAt: (tool valueAt: #cursorPoint))]).	(Tool stateFor: 'Wait for button release (Image Tool)') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Create ImageFigure'); yourself).	(Tool stateFor: 'Image Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Image Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Wait for button release (Image Tool)'); yourself).</body><body package="HotDraw Framework">initializeLineTools	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Polyline Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #class put: PolylineFigure.tool cursor: Cursor crossHair]' runs: (RunArray runs: #(89) values: #(nil))); instVarAt: 4 put: (Point x: 34 y: 18); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Pressed Line Tool'; instVarAt: 3 put: (Text string: '[:tool :event | | figure point |point := tool cursorPointFor: event.figure := (tool valueAt: #class) createAt: point.tool valueAt: #figure put: figure.tool drawing add: figure]' runs: (RunArray runs: #(181) values: #(nil))); instVarAt: 4 put: (Point x: 110 y: 129); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Move Line'; instVarAt: 3 put: (Text string: '[:tool :event | (tool valueAt: #figure) stopPoint: (tool cursorPointFor: event)]' runs: (RunArray runs: #(81) values: #(nil))); instVarAt: 4 put: (Point x: 134 y: 255); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Line Tool End State'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 31 y: 364); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Add Point to Line (Tool)'; instVarAt: 3 put: (Text string: '[:tool :event | (tool valueAt: #figure) addPoint: (tool cursorPointFor: event)]' runs: (RunArray runs: #(80) values: #(nil))); instVarAt: 4 put: (Point x: 324 y: 341); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Spline Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #class put: SplineFigure.tool cursor: Cursor crossHair]' runs: (RunArray runs: #(87) values: #(nil))); instVarAt: 4 put: (Point x: 240 y: 19); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 418 y: 97); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Cancel Figure Creation'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 384 y: 151); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Polyline Tool'); to: (stateTable at: 'Pressed Line Tool'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 87 y: 48); add: (Point x: 154 y: 129); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Pressed Line Tool'); to: (stateTable at: 'Move Line'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 167 y: 160); add: (Point x: 167 y: 255); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Pressed Line Tool'); to: (stateTable at: 'Move Line'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 191 y: 158); add: (Point x: 247 y: 193); add: (Point x: 182 y: 255); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Line'); to: (stateTable at: 'Move Line'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 186 y: 256); add: (Point x: 234 y: 225); add: (Point x: 259 y: 242); add: (Point x: 196 y: 260); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Line'); to: (stateTable at: 'Move Line'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 142 y: 260); add: (Point x: 41 y: 222); add: (Point x: 24 y: 265); add: (Point x: 134 y: 268); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Line'); to: (stateTable at: 'Line Tool End State'); type: (TransitionType basicNew instVarAt: 1 put: #doubleClick; yourself); points: ((OrderedCollection new) add: (Point x: 144 y: 282); add: (Point x: 96 y: 315); add: (Point x: 93 y: 364); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Line'); to: (stateTable at: 'Line Tool End State'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 156 y: 285); add: (Point x: 102 y: 364); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Line'); to: (stateTable at: 'Add Point to Line (Tool)'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 196 y: 280); add: (Point x: 361 y: 342); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Add Point to Line (Tool)'); to: (stateTable at: 'Move Line'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 324 y: 357); add: (Point x: 246 y: 361); add: (Point x: 181 y: 285); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Add Point to Line (Tool)'); to: (stateTable at: 'Move Line'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 391 y: 341); add: (Point x: 334 y: 284); add: (Point x: 202 y: 272); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Spline Tool'); to: (stateTable at: 'Pressed Line Tool'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 257 y: 48); add: (Point x: 181 y: 129); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Spline Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 297 y: 48); add: (Point x: 421 y: 104); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Polyline Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 116 y: 27); add: (Point x: 254 y: 10); add: (Point x: 404 y: 23); add: (Point x: 421 y: 69); add: (Point x: 432 y: 97); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Add Point to Line (Tool)'); to: (stateTable at: 'Cancel Figure Creation'); type: (CharacterTransitionType new event: #keyPress; characters: (String fromIntegerArray: #[27])); points: ((OrderedCollection new) add: (Point x: 400 y: 341); add: (Point x: 448 y: 182); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Move Line'); to: (stateTable at: 'Cancel Figure Creation'); type: (CharacterTransitionType new event: #keyPress; characters: (String fromIntegerArray: #[27])); points: ((OrderedCollection new) add: (Point x: 202 y: 268); add: (Point x: 366 y: 214); add: (Point x: 407 y: 178); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Pressed Line Tool'); to: (stateTable at: 'Cancel Figure Creation'); type: (CharacterTransitionType new event: #keyPress; characters: (String fromIntegerArray: #[27])); points: ((OrderedCollection new) add: (Point x: 224 y: 147); add: (Point x: 261 y: 149); add: (Point x: 389 y: 159); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Polyline Tool' put: (ToolState name: 'Polyline Tool' command: [:tool :event | tool valueAt: #class put: PolylineFigure.tool cursor: Cursor crossHair]).	Tool states at: 'Pressed Line Tool' put: (ToolState name: 'Pressed Line Tool' command: [:tool :event | | figure point |point := tool cursorPointFor: event.figure := (tool valueAt: #class) createAt: point.tool valueAt: #figure put: figure.tool drawing add: figure]).	Tool states at: 'Move Line' put: (ToolState name: 'Move Line' command: [:tool :event | (tool valueAt: #figure) stopPoint: (tool cursorPointFor: event)]).	Tool states at: 'Line Tool End State' put: (EndToolState name: 'Line Tool End State' command: [:tool :event | ]).	Tool states at: 'Add Point to Line (Tool)' put: (ToolState name: 'Add Point to Line (Tool)' command: [:tool :event | (tool valueAt: #figure) addPoint: (tool cursorPointFor: event)]).	Tool states at: 'Spline Tool' put: (ToolState name: 'Spline Tool' command: [:tool :event | tool valueAt: #class put: SplineFigure.tool cursor: Cursor crossHair]).	(Tool stateFor: 'Polyline Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Pressed Line Tool'); yourself).	(Tool stateFor: 'Polyline Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Add Point to Line (Tool)') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Line'); yourself).	(Tool stateFor: 'Add Point to Line (Tool)') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Line'); yourself).	(Tool stateFor: 'Add Point to Line (Tool)') keyPress: ((CharacterTransitionTable new) forCharacters: (String fromIntegerArray: #[27]) goto: (Tool stateFor: 'Cancel Figure Creation'); yourself).	(Tool stateFor: 'Pressed Line Tool') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Line'); yourself).	(Tool stateFor: 'Pressed Line Tool') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Line'); yourself).	(Tool stateFor: 'Pressed Line Tool') keyPress: ((CharacterTransitionTable new) forCharacters: (String fromIntegerArray: #[27]) goto: (Tool stateFor: 'Cancel Figure Creation'); yourself).	(Tool stateFor: 'Move Line') doubleClick: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Line Tool End State'); yourself).	(Tool stateFor: 'Move Line') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Line'); yourself).	(Tool stateFor: 'Move Line') keyPress: ((CharacterTransitionTable new) forCharacters: (String fromIntegerArray: #[27]) goto: (Tool stateFor: 'Cancel Figure Creation'); yourself).	(Tool stateFor: 'Move Line') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Line Tool End State'); yourself).	(Tool stateFor: 'Move Line') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Add Point to Line (Tool)'); yourself).	(Tool stateFor: 'Move Line') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Move Line'); yourself).	(Tool stateFor: 'Spline Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Pressed Line Tool'); yourself).	(Tool stateFor: 'Spline Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).</body><body package="HotDraw Framework">initializeOriginCornerCreationTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Create Origin/Corner Figure'; instVarAt: 3 put: (Text string: '[:tool :event | | figure |tool cursor: Cursor corner.figure := (tool valueAt: #class) createAt: (tool cursorPointFor: event).tool valueAt: #figure put: figure.tool drawing add: figure.tool valueAt: #moveBlock put: [:aPoint | figure bottomRight: aPoint]]' runs: (RunArray runs: #(259) values: #(nil))); instVarAt: 4 put: (Point x: 139 y: 147); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Track handle move'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 104 y: 278); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Cancel Figure Creation'; instVarAt: 3 put: (Text string: '[:tool :event | tool drawing remove: (tool valueAt: #figure)]' runs: (RunArray runs: #(62) values: #(nil))); instVarAt: 4 put: (Point x: 298 y: 268); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Ellipse Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #class put: EllipseFigure.tool cursor: Cursor origin]' runs: (RunArray runs: #(85) values: #(nil))); instVarAt: 4 put: (Point x: 51 y: 65); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Rectangle Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #class put: RectangleFigure.tool cursor: Cursor origin]' runs: (RunArray runs: #(87) values: #(nil))); instVarAt: 4 put: (Point x: 394 y: 53); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 239 y: 375); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Rounded Rectangle Tool'; instVarAt: 3 put: '[:tool :event | tool valueAt: #class put: RoundedRectangleFigure.tool cursor: Cursor origin]'; instVarAt: 4 put: (Point x: 114 y: 15); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Arc Tool'; instVarAt: 3 put: '[:tool :event | tool valueAt: #class put: ArcFigure.tool cursor: Cursor origin]'; instVarAt: 4 put: (Point x: 295 y: 18); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Create Origin/Corner Figure'); to: (stateTable at: 'Track handle move'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 215 y: 177); add: (Point x: 169 y: 278); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Create Origin/Corner Figure'); to: (stateTable at: 'Cancel Figure Creation'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 242 y: 177); add: (Point x: 352 y: 268); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Ellipse Tool'); to: (stateTable at: 'Create Origin/Corner Figure'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 114 y: 93); add: (Point x: 200 y: 147); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Rectangle Tool'); to: (stateTable at: 'Create Origin/Corner Figure'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 408 y: 80); add: (Point x: 254 y: 147); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Rectangle Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 442 y: 84); add: (Point x: 453 y: 323); add: (Point x: 371 y: 355); add: (Point x: 280 y: 383); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Ellipse Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 86 y: 96); add: (Point x: 67 y: 330); add: (Point x: 240 y: 383); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Rounded Rectangle Tool'); to: (stateTable at: 'Create Origin/Corner Figure'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 198 y: 45); add: (Point x: 231 y: 147); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Rounded Rectangle Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 115 y: 34); add: (Point x: 30 y: 35); add: (Point x: 12 y: 374); add: (Point x: 239 y: 388); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Arc Tool'); to: (stateTable at: 'Create Origin/Corner Figure'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 320 y: 49); add: (Point x: 236 y: 147); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Arc Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 353 y: 30); add: (Point x: 393 y: 26); add: (Point x: 413 y: 25); add: (Point x: 436 y: 25); add: (Point x: 493 y: 26); add: (Point x: 495 y: 209); add: (Point x: 470 y: 372); add: (Point x: 281 y: 391); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Create Origin/Corner Figure' put: (ToolState name: 'Create Origin/Corner Figure' command: [:tool :event | | figure |tool cursor: Cursor corner.figure := (tool valueAt: #class) createAt: (tool cursorPointFor: event).tool valueAt: #figure put: figure.tool drawing add: figure.tool valueAt: #moveBlock put: [:aPoint | figure bottomRight: aPoint]]).	Tool states at: 'Cancel Figure Creation' put: (EndToolState name: 'Cancel Figure Creation' command: [:tool :event | tool drawing remove: (tool valueAt: #figure)]).	Tool states at: 'Ellipse Tool' put: (ToolState name: 'Ellipse Tool' command: [:tool :event | tool valueAt: #class put: EllipseFigure.tool cursor: Cursor origin]).	Tool states at: 'Rectangle Tool' put: (ToolState name: 'Rectangle Tool' command: [:tool :event | tool valueAt: #class put: RectangleFigure.tool cursor: Cursor origin]).	Tool states at: 'Rounded Rectangle Tool' put: (ToolState name: 'Rounded Rectangle Tool' command: [:tool :event | tool valueAt: #class put: RoundedRectangleFigure.tool cursor: Cursor origin]).	Tool states at: 'Arc Tool' put: (ToolState name: 'Arc Tool' command: [:tool :event | tool valueAt: #class put: ArcFigure.tool cursor: Cursor origin]).	(Tool stateFor: 'Arc Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Create Origin/Corner Figure'); yourself).	(Tool stateFor: 'Arc Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Rectangle Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Create Origin/Corner Figure'); yourself).	(Tool stateFor: 'Rectangle Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Create Origin/Corner Figure') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Cancel Figure Creation'); yourself).	(Tool stateFor: 'Create Origin/Corner Figure') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Track handle move'); yourself).	(Tool stateFor: 'Rounded Rectangle Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Create Origin/Corner Figure'); yourself).	(Tool stateFor: 'Rounded Rectangle Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Ellipse Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Create Origin/Corner Figure'); yourself).	(Tool stateFor: 'Ellipse Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).</body><body package="HotDraw Framework">initializeSelectionToolMultiseletion	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool Multi-select'; instVarAt: 3 put: (Text string: '[:tool :event | | point |point := tool cursorPointFor: event.tool valueAt: #initialPoint put: point;	valueAt: #lastPoint put: point]' runs: (RunArray runs: #(136) values: #(nil))); instVarAt: 4 put: (Point x: 16 y: 45); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'multi-selection move'; instVarAt: 3 put: (Text string: '[:tool :event | | gc newPoint origin |origin := tool valueAt: #initialPoint.tool drawing	invalidateRectangle: (Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.gc := tool drawing graphicsContext.newPoint := tool cursorPointFor: event.gc displayRectangularBorder: (Rectangle vertex: origin vertex: newPoint).tool valueAt: #lastPoint put: newPoint]' runs: (RunArray runs: #(383) values: #(nil))); instVarAt: 4 put: (Point x: 135 y: 156); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'multi-selection release'; instVarAt: 3 put: (Text string: '[:tool :event | | origin lastPoint rect figures |origin := tool valueAt: #initialPoint.lastPoint := tool valueAt: #lastPoint.rect := Rectangle vertex: origin vertex: lastPoint.tool drawing invalidateRectangle: rect.figures := tool drawing figuresIn: rect.tool sensor shiftDown 	ifTrue: [tool drawing toggleSelections: figures] 	ifFalse: [tool drawing selections: figures]]' runs: (RunArray runs: #(381) values: #(nil))); instVarAt: 4 put: (Point x: 35 y: 332); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool Multi-select'); to: (stateTable at: 'multi-selection move'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 109 y: 75); add: (Point x: 184 y: 156); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'multi-selection move'); to: (stateTable at: 'multi-selection move'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 245 y: 160); add: (Point x: 323 y: 143); add: (Point x: 323 y: 163); add: (Point x: 261 y: 167); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'multi-selection move'); to: (stateTable at: 'multi-selection release'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 190 y: 186); add: (Point x: 111 y: 332); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool Multi-select'); to: (stateTable at: 'multi-selection release'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 97 y: 76); add: (Point x: 104 y: 332); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Selection Tool Multi-select' put: (ToolState name: 'Selection Tool Multi-select' command: [:tool :event | | point |point := tool cursorPointFor: event.tool valueAt: #initialPoint put: point;	valueAt: #lastPoint put: point]).	Tool states at: 'multi-selection move' put: (ToolState name: 'multi-selection move' command: [:tool :event | | gc newPoint origin |origin := tool valueAt: #initialPoint.tool drawing	invalidateRectangle: (Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.gc := tool drawing graphicsContext.newPoint := tool cursorPointFor: event.gc displayRectangularBorder: (Rectangle vertex: origin vertex: newPoint).tool valueAt: #lastPoint put: newPoint]).	Tool states at: 'multi-selection release' put: (EndToolState name: 'multi-selection release' command: [:tool :event | | origin lastPoint rect figures |origin := tool valueAt: #initialPoint.lastPoint := tool valueAt: #lastPoint.rect := Rectangle vertex: origin vertex: lastPoint.tool drawing invalidateRectangle: rect.figures := tool drawing figuresIn: rect.tool sensor shiftDown 	ifTrue: [tool drawing toggleSelections: figures] 	ifFalse: [tool drawing selections: figures]]).	(Tool stateFor: 'Selection Tool Multi-select') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'multi-selection release'); yourself).	(Tool stateFor: 'Selection Tool Multi-select') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'multi-selection move'); yourself).	(Tool stateFor: 'multi-selection move') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'multi-selection release'); yourself).	(Tool stateFor: 'multi-selection move') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'multi-selection move'); yourself).</body><body package="HotDraw Framework">initializeSelectionToolSelection	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool Select'; instVarAt: 3 put: (Text string: '[:tool :event | | drawing lastPoint figure |drawing := tool drawing.lastPoint := tool cursorPointFor: event.tool valueAt: #lastPoint put: lastPoint.figure := drawing figureAt: lastPoint.tool sensor shiftDown	ifTrue: [drawing toggleSelection: figure]	ifFalse: [(drawing isSelected: figure) ifFalse: [drawing selection: figure]]]' runs: (RunArray runs: #(335) values: #(nil))); instVarAt: 4 put: (Point x: 46 y: 51); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool Move Figure'; instVarAt: 3 put: (Text string: '[:tool :event | | delta newPoint |newPoint := tool cursorPointFor: event.delta := newPoint - (tool valueAt: #lastPoint).tool valueAt: #lastPoint put: newPoint.tool drawing selections do: [:each | each translateBy: delta]]' runs: (RunArray runs: #(226) values: #(nil))); instVarAt: 4 put: (Point x: 133 y: 140); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'End State'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 55 y: 253); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool Select'); to: (stateTable at: 'Selection Tool Move Figure'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 137 y: 81); add: (Point x: 222 y: 140); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool Move Figure'); to: (stateTable at: 'Selection Tool Move Figure'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 252 y: 141); add: (Point x: 358 y: 131); add: (Point x: 358 y: 151); add: (Point x: 299 y: 154); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool Move Figure'); to: (stateTable at: 'End State'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 209 y: 171); add: (Point x: 104 y: 253); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool Select'); to: (stateTable at: 'End State'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 117 y: 82); add: (Point x: 90 y: 253); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Selection Tool Select' put: (ToolState name: 'Selection Tool Select' command: [:tool :event | | drawing lastPoint figure |drawing := tool drawing.lastPoint := tool cursorPointFor: event.tool valueAt: #lastPoint put: lastPoint.figure := drawing figureAt: lastPoint.tool sensor shiftDown	ifTrue: [drawing toggleSelection: figure]	ifFalse: [(drawing isSelected: figure) ifFalse: [drawing selection: figure]]]).	Tool states at: 'Selection Tool Move Figure' put: (ToolState name: 'Selection Tool Move Figure' command: [:tool :event | | delta newPoint |newPoint := tool cursorPointFor: event.delta := newPoint - (tool valueAt: #lastPoint).tool valueAt: #lastPoint put: newPoint.tool drawing selections do: [:each | each translateBy: delta]]).	Tool states at: 'End State' put: (EndToolState name: 'End State' command: [:tool :event | ]).	(Tool stateFor: 'Selection Tool Select') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'End State'); yourself).	(Tool stateFor: 'Selection Tool Select') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Selection Tool Move Figure'); yourself).	(Tool stateFor: 'Selection Tool Move Figure') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'End State'); yourself).	(Tool stateFor: 'Selection Tool Move Figure') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Selection Tool Move Figure'); yourself).</body><body package="HotDraw Framework">initializeSelectionToolStates	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool cursor: Cursor normal]' runs: (RunArray runs: #(43) values: #(nil))); instVarAt: 4 put: (Point x: 198 y: 21); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool Select'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 26 y: 140); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: (Text string: '[:tool :event | tool controller processMenuAt: event globalPoint	local: (tool cursorPointFor: event)	for: (tool figureAtEvent: event)]' runs: (RunArray runs: #(137) values: #(nil))); instVarAt: 4 put: (Point x: 109 y: 261); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool Multi-select'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 226 y: 334); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Handle Processing'; instVarAt: 3 put: (Text string: '[:tool :event | tool changeToState: (tool figureAtEvent: event) toolState event: event]' runs: (RunArray runs: #(87) values: #(nil))); instVarAt: 4 put: (Point x: 411 y: 253); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Selection Tool Remove Figures'; instVarAt: 3 put: (Text string: '[:tool :event | tool drawing removeAll: (tool drawing selections copy)]' runs: (RunArray runs: #(71) values: #(nil))); instVarAt: 4 put: (Point x: 345 y: 111); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool'); to: (stateTable at: 'Selection Tool Select'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 221 y: 50); add: (Point x: 109 y: 140); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 236 y: 51); add: (Point x: 136 y: 261); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool'); to: (stateTable at: 'Selection Tool Multi-select'); type: (FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Array new: 1) at: 1 put: Drawing; yourself); yourself); points: ((OrderedCollection new) add: (Point x: 246 y: 52); add: (Point x: 304 y: 334); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool'); to: (stateTable at: 'Handle Processing'); type: (FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Array new: 1) at: 1 put: Handle; yourself); yourself); points: ((OrderedCollection new) add: (Point x: 259 y: 51); add: (Point x: 455 y: 253); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Selection Tool'); to: (stateTable at: 'Selection Tool Remove Figures'); type: (CharacterTransitionType new event: #keyPress; characters: (String fromIntegerArray: #[8 127])); points: ((OrderedCollection new) add: (Point x: 290 y: 39); add: (Point x: 364 y: 39); add: (Point x: 409 y: 111); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Selection Tool' put: (ToolState name: 'Selection Tool' command: [:tool :event | tool cursor: Cursor normal]).	Tool states at: 'Menu' put: (EndToolState name: 'Menu' command: [:tool :event | tool controller processMenuAt: event globalPoint	local: (tool cursorPointFor: event)	for: (tool figureAtEvent: event)]).	Tool states at: 'Handle Processing' put: (ToolState name: 'Handle Processing' command: [:tool :event | tool changeToState: (tool figureAtEvent: event) toolState event: event]).	Tool states at: 'Selection Tool Remove Figures' put: (EndToolState name: 'Selection Tool Remove Figures' command: [:tool :event | tool drawing removeAll: (tool drawing selections copy)]).	(Tool stateFor: 'Selection Tool') keyPress: ((CharacterTransitionTable new) forCharacters: (String fromIntegerArray: #[8 127]) goto: (Tool stateFor: 'Selection Tool Remove Figures'); yourself).	(Tool stateFor: 'Selection Tool') redButtonPress: ((FigureTransitionTable new)  on: Handle goto: (Tool stateFor: 'Handle Processing');  on: Drawing goto: (Tool stateFor: 'Selection Tool Multi-select'); goto: (Tool stateFor: 'Selection Tool Select'); yourself).	(Tool stateFor: 'Selection Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).</body><body package="HotDraw Framework">initializeSendToBackTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Send To Back Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool cursor: Cursor crossHair]' runs: (RunArray runs: #(46) values: #(nil))); instVarAt: 4 put: (Point x: 171 y: 50); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Send To Back Press'; instVarAt: 3 put: (Text string: '[:tool :event | | figure |figure := tool figureAtEvent: event.(figure isHandle or: [figure isDrawing])	ifFalse: [tool drawing sendToBack: figure]]' runs: (RunArray runs: #(150) values: #(nil))); instVarAt: 4 put: (Point x: 100 y: 189); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 362 y: 191); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Send To Back Tool'); to: (stateTable at: 'Send To Back Press'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 232 y: 81); add: (Point x: 172 y: 189); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Send To Back Tool'); to: (stateTable at: 'Menu'); type: (TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((OrderedCollection new) add: (Point x: 271 y: 78); add: (Point x: 371 y: 193); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Send To Back Tool' put: (ToolState name: 'Send To Back Tool' command: [:tool :event | tool cursor: Cursor crossHair]).	Tool states at: 'Send To Back Press' put: (EndToolState name: 'Send To Back Press' command: [:tool :event | | figure |figure := tool figureAtEvent: event.(figure isHandle or: [figure isDrawing])	ifFalse: [tool drawing sendToBack: figure]]).	(Tool stateFor: 'Send To Back Tool') redButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Send To Back Press'); yourself).	(Tool stateFor: 'Send To Back Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).</body><body package="HotDraw Framework">initializeTextTool	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((Core.OrderedCollection new) add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Text Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #canCreate put: false]' runs: (Core.RunArray runs: #(53) values: #(nil))); instVarAt: 4 put: (Core.Point x: 87 y: 41); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Select Text Figure'; instVarAt: 3 put: (Text string: '[:tool :event | | figure startIndex |figure := tool figureAtEvent: event.tool drawing selection: figure.tool valueAt: #figure put: figure.startIndex := figure indexForPoint: (tool cursorPointFor: event).tool valueAt: #startIndex put: startIndex.figure setIndices: (startIndex to: startIndex)]' runs: (Core.RunArray runs: #(299) values: #(nil))); instVarAt: 4 put: (Core.Point x: 60 y: 173); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Highlight Text'; instVarAt: 3 put: (Text string: '[:tool :event | | figure newIndex startIndex |figure := tool valueAt: #figure.startIndex := tool valueAt: #startIndex.newIndex := figure indexForPoint: (tool cursorPointFor: event).figure setIndices: 	((newIndex min: startIndex) to: (newIndex max: startIndex))]' runs: (Core.RunArray runs: #(267) values: #(nil))); instVarAt: 4 put: (Core.Point x: 59 y: 243); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Text Figure Selected'; instVarAt: 3 put: (Text string: '[:tool :event | ]' runs: (Core.RunArray runs: #(17) values: #(nil))); instVarAt: 4 put: (Core.Point x: 276 y: 242); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Text Figure Creation Tool'; instVarAt: 3 put: (Text string: '[:tool :event | tool valueAt: #canCreate put: true]' runs: (Core.RunArray runs: #(52) values: #(nil))); instVarAt: 4 put: (Core.Point x: 273 y: 27); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Create Text'; instVarAt: 3 put: (Text string: '[:tool :event | | figure |(tool valueAt: #canCreate) 	ifTrue: 		[figure := TextFigure string: '''' 				at: (tool cursorPointFor: event).		figure setIndices: (1 to: 1).		tool drawing add: figure; selection: figure.		tool valueAt: #figure put: figure] 	ifFalse: 		[tool changeToState: (Tool stateFor: ''End State'') 			event: event]]' runs: (Core.RunArray runs: #(276 61 1) values: #(nil #bold nil))); instVarAt: 4 put: (Core.Point x: 375 y: 109); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Edit Text Figure'; instVarAt: 3 put: '[:tool :event | (tool valueAt: #figure) respondToEvent: event]'; instVarAt: 4 put: (Core.Point x: 303 y: 312); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 316 y: 369); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Tool'); to: (stateTable at: 'Select Text Figure'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.HotDraw.TextFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 117.0 y: 68.625); add: (Core.Point x: 117.0 y: 172.185); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Select Text Figure'); to: (stateTable at: 'Highlight Text'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 114.375 y: 200.625); add: (Core.Point x: 105.146 y: 242.338); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Highlight Text'); to: (stateTable at: 'Highlight Text'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 106.062 y: 270.625); add: (Core.Point x: 117 y: 311); add: (Core.Point x: 90 y: 318); add: (Core.Point x: 90.625 y: 269.812); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Highlight Text'); to: (stateTable at: 'Text Figure Selected'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 146.563 y: 256.0); add: (Core.Point x: 172 y: 256); add: (Core.Point x: 274.88 y: 255.992); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Select Text Figure'); to: (stateTable at: 'Text Figure Selected'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 164.125 y: 193.875); add: (Core.Point x: 200 y: 206); add: (Core.Point x: 301.494 y: 242.711); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Selected'); to: (stateTable at: 'Select Text Figure'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.HotDraw.TextFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 326.477 y: 241.367); add: (Core.Point x: 260 y: 161); add: (Core.Point x: 173.187 y: 185.047); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Creation Tool'); to: (stateTable at: 'Create Text'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 358.75 y: 53.8125); add: (Core.Point x: 400.34 y: 108.138); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Creation Tool'); to: (stateTable at: 'Select Text Figure'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.HotDraw.TextFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 324.625 y: 53.8125); add: (Core.Point x: 140.45 y: 172.069); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Create Text'); to: (stateTable at: 'Text Figure Selected'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 405.25 y: 136.344); add: (Core.Point x: 348.447 y: 241.175); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Selected'); to: (stateTable at: 'Create Text'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 383.305 y: 244.375); add: (Core.Point x: 422 y: 165); add: (Core.Point x: 418.5 y: 135.812); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Edit Text Figure'); to: (stateTable at: 'Edit Text Figure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #keyPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 402.516 y: 326.906); add: (Core.Point x: 425 y: 331); add: (Core.Point x: 425 y: 351); add: (Core.Point x: 389.812 y: 335.313); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Selected'); to: (stateTable at: 'Edit Text Figure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #keyPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 342.25 y: 269.625); add: (Core.Point x: 349.879 y: 311.338); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Edit Text Figure'); to: (stateTable at: 'Select Text Figure'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.HotDraw.TextFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 309.109 y: 333.578); add: (Core.Point x: 179 y: 367); add: (Core.Point x: 52 y: 312); add: (Core.Point x: 75.2187 y: 196.875); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Edit Text Figure'); to: (stateTable at: 'Create Text'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 393.944 y: 316.433); add: (Core.Point x: 433 y: 272); add: (Core.Point x: 433.094 y: 134.656); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Edit Text Figure'); to: (stateTable at: 'Menu'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 348.75 y: 339.625); add: (Core.Point x: 339.305 y: 368.082); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Selected'); to: (stateTable at: 'Menu'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 335.75 y: 269.625); add: (Core.Point x: 256 y: 294); add: (Core.Point x: 226 y: 339); add: (Core.Point x: 259 y: 388); add: (Core.Point x: 315.109 y: 385.047); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Figure Creation Tool'); to: (stateTable at: 'Menu'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 421.516 y: 44.6484); add: (Core.Point x: 483 y: 57); add: (Core.Point x: 508 y: 203); add: (Core.Point x: 491 y: 390); add: (Core.Point x: 357 y: 389); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Text Tool'); to: (stateTable at: 'Menu'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #yellowButtonPress; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 96.0 y: 64.5); add: (Core.Point x: 29 y: 142); add: (Core.Point x: 22 y: 273); add: (Core.Point x: 37 y: 385); add: (Core.Point x: 105 y: 402); add: (Core.Point x: 180 y: 401); add: (Core.Point x: 318.25 y: 389.5); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Text Tool' put: (ToolState name: 'Text Tool' command: [:tool :event | tool valueAt: #canCreate put: false]).	Tool states at: 'Select Text Figure' put: (ToolState name: 'Select Text Figure' command: [:tool :event | | figure startIndex |figure := tool figureAtEvent: event.tool drawing selection: figure.tool valueAt: #figure put: figure.startIndex := figure indexForPoint: (tool cursorPointFor: event).tool valueAt: #startIndex put: startIndex.figure setIndices: (startIndex to: startIndex)]).	Tool states at: 'Highlight Text' put: (ToolState name: 'Highlight Text' command: [:tool :event | | figure newIndex startIndex |figure := tool valueAt: #figure.startIndex := tool valueAt: #startIndex.newIndex := figure indexForPoint: (tool cursorPointFor: event).figure setIndices: 	((newIndex min: startIndex) to: (newIndex max: startIndex))]).	Tool states at: 'Text Figure Selected' put: (ToolState name: 'Text Figure Selected' command: [:tool :event | ]).	Tool states at: 'Text Figure Creation Tool' put: (ToolState name: 'Text Figure Creation Tool' command: [:tool :event | tool valueAt: #canCreate put: true]).	Tool states at: 'Create Text' put: (ToolState name: 'Create Text' command: [:tool :event | | figure |(tool valueAt: #canCreate) 	ifTrue: 		[figure := TextFigure string: '' 				at: (tool cursorPointFor: event).		figure setIndices: (1 to: 1).		tool drawing add: figure; selection: figure.		tool valueAt: #figure put: figure] 	ifFalse: 		[tool changeToState: (Tool stateFor: 'End State') 			event: event]]).	Tool states at: 'Edit Text Figure' put: (ToolState name: 'Edit Text Figure' command: [:tool :event | (tool valueAt: #figure) respondToEvent: event]).	(Tool stateFor: 'Text Tool') redButtonPress: ((FigureTransitionTable new)  on: Refactory.HotDraw.TextFigure goto: (Tool stateFor: 'Select Text Figure'); yourself).	(Tool stateFor: 'Text Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Create Text') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Text Figure Selected'); yourself).	(Tool stateFor: 'Edit Text Figure') redButtonPress: ((FigureTransitionTable new)  on: Refactory.HotDraw.TextFigure goto: (Tool stateFor: 'Select Text Figure'); goto: (Tool stateFor: 'Create Text'); yourself).	(Tool stateFor: 'Edit Text Figure') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Edit Text Figure') keyPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Edit Text Figure'); yourself).	(Tool stateFor: 'Highlight Text') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Highlight Text'); yourself).	(Tool stateFor: 'Highlight Text') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Text Figure Selected'); yourself).	(Tool stateFor: 'Text Figure Creation Tool') redButtonPress: ((FigureTransitionTable new)  on: Refactory.HotDraw.TextFigure goto: (Tool stateFor: 'Select Text Figure'); goto: (Tool stateFor: 'Create Text'); yourself).	(Tool stateFor: 'Text Figure Creation Tool') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Text Figure Selected') redButtonPress: ((FigureTransitionTable new)  on: Refactory.HotDraw.TextFigure goto: (Tool stateFor: 'Select Text Figure'); goto: (Tool stateFor: 'Create Text'); yourself).	(Tool stateFor: 'Text Figure Selected') yellowButtonPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Text Figure Selected') keyPress: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Edit Text Figure'); yourself).	(Tool stateFor: 'Select Text Figure') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Highlight Text'); yourself).	(Tool stateFor: 'Select Text Figure') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Text Figure Selected'); yourself).</body><body package="HotDraw Framework">initializeTrackHandleStates	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((OrderedCollection new) add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Track Handle'; instVarAt: 3 put: (Text string: '[:tool :event | | handle |handle := tool figureAtEvent: event.tool valueAt: #moveBlock put: handle moveBlock]' runs: (RunArray runs: #(112) values: #(nil))); instVarAt: 4 put: (Point x: 149 y: 30); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Track handle move'; instVarAt: 3 put: (Text string: '[:tool :event | (tool valueAt: #moveBlock) value: (tool cursorPointFor: event)]' runs: (RunArray runs: #(79) values: #(nil))); instVarAt: 4 put: (Point x: 170 y: 173); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Track Handle Release'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Point x: 61 y: 275); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Tentative Position Handle'; instVarAt: 3 put: '[:tool :event | | handle |handle := tool figureAtEvent: event.handle owner addPoint: (tool cursorPointFor: event) beforeIndex: handle index.tool drawing selections: tool drawing selections copy]'; instVarAt: 4 put: (Point x: 336 y: 101); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Track Handle'); to: (stateTable at: 'Track handle move'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 185.297 y: 60.8828); add: (Point x: 222.705 y: 172.124); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Track handle move'); to: (stateTable at: 'Track handle move'); type: (TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((OrderedCollection new) add: (Point x: 287.703 y: 184.0); add: (Point x: 332 y: 184); add: (Point x: 332 y: 204); add: (Point x: 280.813 y: 197.109); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Track handle move'); to: (stateTable at: 'Track Handle Release'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 204.414 y: 203.562); add: (Point x: 130.581 y: 274.442); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Track Handle'); to: (stateTable at: 'Track Handle Release'); type: (TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((OrderedCollection new) add: (Point x: 153.233 y: 53.6056); add: (Point x: 104.19 y: 274.136); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Tentative Position Handle'); to: (stateTable at: 'Track Handle'); type: (TransitionType basicNew instVarAt: 1 put: #immediate; yourself); points: ((OrderedCollection new) add: (Point x: 413.449 y: 100.331); add: (Point x: 224.726 y: 56.2372); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Track Handle' put: (ToolState name: 'Track Handle' command: [:tool :event | | handle |handle := tool figureAtEvent: event.tool valueAt: #moveBlock put: handle moveBlock]).	Tool states at: 'Track handle move' put: (ToolState name: 'Track handle move' command: [:tool :event | (tool valueAt: #moveBlock) value: (tool cursorPointFor: event)]).	Tool states at: 'Track Handle Release' put: (EndToolState name: 'Track Handle Release' command: [:tool :event | ]).	Tool states at: 'Tentative Position Handle' put: (ToolState name: 'Tentative Position Handle' command: [:tool :event | | handle |handle := tool figureAtEvent: event.handle owner addPoint: (tool cursorPointFor: event) beforeIndex: handle index.tool drawing selections: tool drawing selections copy]).	(Tool stateFor: 'Track handle move') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Track handle move'); yourself).	(Tool stateFor: 'Track handle move') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Track Handle Release'); yourself).	(Tool stateFor: 'Track Handle') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Track handle move'); yourself).	(Tool stateFor: 'Track Handle') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Track Handle Release'); yourself).	(Tool stateFor: 'Tentative Position Handle') immediate: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Track Handle'); yourself).</body></methods><methods><class-id>Refactory.HotDraw.TentativePositionHandle</class-id> <category>accessing</category><body package="HotDraw Framework">index	^index</body><body package="HotDraw Framework">index: anInteger 	index := anInteger</body></methods><methods><class-id>Refactory.HotDraw.TentativePositionHandle class</class-id> <category>instance creation</category><body package="HotDraw Framework">forSegment: anIndex of: aFigure 	^(self new)		toolState: (Tool stateFor: 'Tentative Position Handle');		owner: aFigure;		constrain: #center			to: (MessageSend 					receiver: aFigure					selector: #centerOfSegment:					arguments: (Array with: anIndex));		index: anIndex + 1;		moveBlock: [:aPoint | aFigure pointAt: anIndex + 1 put: aPoint];		yourself</body></methods><methods><class-id>Refactory.HotDraw.TentativePositionHandle class</class-id> <category>accessing</category><body package="HotDraw Framework">handleHardColor	^ColorValue gray</body></methods><methods><class-id>Refactory.HotDraw.ArcFigure</class-id> <category>accessing</category><body package="HotDraw Framework">handles	| handles |	handles := OrderedCollection withAll: super handles.	handles		add: ((TrackHandle on: self at: #startAnglePosition)					moveBlock: [:aPoint | self trackStartAngle: aPoint];					yourself);		add: ((TrackHandle on: self at: #stopAnglePosition)					moveBlock: [:aPoint | self trackStopAngle: aPoint];					yourself).	^handles</body><body package="HotDraw Framework">startAngle	^startAngle min: stopAngle</body><body package="HotDraw Framework">startAngle: anInteger 	startAngle := anInteger.	self changed</body><body package="HotDraw Framework">startAnglePosition	^self positionForAngle: startAngle</body><body package="HotDraw Framework">stopAngle	^stopAngle max: startAngle</body><body package="HotDraw Framework">stopAngle: anInteger 	stopAngle := anInteger.	self changed</body><body package="HotDraw Framework">stopAnglePosition	^self positionForAngle: stopAngle</body><body package="HotDraw Framework">sweepAngle	^stopAngle = startAngle 		ifTrue: [360]		ifFalse: [self stopAngle - self startAngle]</body><body package="HotDraw Framework">trackStartAngle: aPoint 	self startAngle: (self convertThetaToAngle: (self normalizePoint: aPoint) theta)</body><body package="HotDraw Framework">trackStopAngle: aPoint 	self stopAngle: (self convertThetaToAngle: (self normalizePoint: aPoint) theta)</body></methods><methods><class-id>Refactory.HotDraw.ArcFigure</class-id> <category>displaying</category><body package="HotDraw Framework">displayFigureOn: aGraphicsContext 	super displayFigureOn: aGraphicsContext.	self lineWidth &gt; 0 ifFalse: [^self].	aGraphicsContext		lineWidth: self lineWidth;		paint: self lineColor.	(LineSegment from: self center to: self startAnglePosition) 		displayStrokedOn: aGraphicsContext.	(LineSegment from: self center to: self stopAnglePosition) 		displayStrokedOn: aGraphicsContext</body></methods><methods><class-id>Refactory.HotDraw.ArcFigure</class-id> <category>private</category><body package="HotDraw Framework">convertAngleToTheta: anAngle 	^anAngle / 360.0 * (2 * Double pi)</body><body package="HotDraw Framework">convertThetaToAngle: aNumber 	^(aNumber * 360 / (2 * Double pi)) rounded</body><body package="HotDraw Framework">normalizePoint: aPoint 	| vector extent |	extent := self extent.	(extent x &lt;= 0 or: [extent y &lt;= 0]) ifTrue: [^0 @ 0].	vector := aPoint - self center.	vector := (vector x asFloat / extent x) @ (vector y asFloat / extent y).	0 @ 0 = vector ifTrue: [^0 @ 0].	^vector</body><body package="HotDraw Framework">positionForAngle: anAngle 	| theta |	theta := self convertAngleToTheta: anAngle.	^self center 		+ ((Point r: self extent x / 2.0 theta: theta) x 				@ (Point r: self extent y / 2.0 theta: theta) y) rounded</body></methods><methods><class-id>Refactory.HotDraw.ArcFigure</class-id> <category>testing</category><body package="HotDraw Framework">containsPoint: aPoint 	"Overriden, because regionIntersects: has a bug for small arcs"	| outer angle strtAngle |	self isOpaque ifFalse: [^super containsPoint: aPoint].	self center = aPoint ifTrue: [^true].	angle := self 				convertThetaToAngle: (self normalizePoint: aPoint rounded) theta.	strtAngle := self startAngle.	(angle between: strtAngle and: strtAngle + self sweepAngle) 		ifFalse: [^false].	outer := self positionForAngle: angle.	^aPoint rounded between: (self center min: outer)		and: (self center max: outer)</body></methods><methods><class-id>Refactory.HotDraw.ArcFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">ellipse: aRect 	super ellipse: aRect.	startAngle := 0.	stopAngle := 360</body></methods><methods><class-id>Refactory.HotDraw.ImageFigure</class-id> <category>initialize-release</category><body package="HotDraw Framework">flushCaches	"Do nothing, if our caches are flushed we cannot rebuild them."</body></methods><methods><class-id>Refactory.HotDraw.ImageFigure</class-id> <category>private</category><body package="HotDraw Framework">fillCache	"Get the image from the user to display."	^Image fromUser</body></methods><methods><class-id>Refactory.HotDraw.ImageFigure class</class-id> <category>instance creation</category><body package="HotDraw Framework">createAt: aPoint 	^(self new)		origin: aPoint;		yourself</body></methods><methods><class-id>Refactory.HotDraw.FigureAttributes</class-id> <category>accessing</category><body package="HotDraw Framework">fillColor	^fillColor</body><body package="HotDraw Framework">fillColor: aColorValue 	fillColor := aColorValue</body><body package="HotDraw Framework">lineColor	^lineColor</body><body package="HotDraw Framework">lineColor: aColorValue 	lineColor := aColorValue</body><body package="HotDraw Framework">lineWidth	^lineWidth</body><body package="HotDraw Framework">lineWidth: anInteger 	lineWidth := anInteger</body></methods><methods><class-id>Refactory.HotDraw.FigureAttributes</class-id> <category>printing</category><body package="HotDraw Framework">printOn: aStream	| offset |	super printOn: aStream.	1 to: self class instSize - (offset := self class superclass instSize) do:		[:i|		(self instVarAt: i + offset) notNil ifTrue:			[aStream space; nextPutAll: (self class instVarNames at: i); nextPut: $:; space; print: (self instVarAt: i + offset)]]</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor class</class-id> <category>resources</category><body package="HotDraw Framework">arcIconImage	"UIMaskEditor new openOnClass: self andSelector: #arcIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 248 126 0 0 231 158 0 0 223 190 0 0 223 126 0 0 190 254 0 0 190 254 0 0 223 126 0 0 223 190 0 0 231 158 0 0 248 126 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">arcIconMask	"UIMaskEditor new openOnClass: self andSelector: #arcIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 31 224 0 0 63 192 0 0 63 128 0 0 127 0 0 0 127 0 0 0 63 128 0 0 63 192 0 0 31 224 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">bezierIconImage	"UIMaskEditor new openOnClass: self andSelector: #bezierIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 242 0 0 255 242 0 0 255 242 0 0 255 230 0 0 255 206 0 0 255 30 0 0 252 126 0 0 241 254 0 0 231 254 0 0 207 254 0 0 159 254 0 0 159 254 0 0 159 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">bezierIconMask	"UIMaskEditor new openOnClass: self andSelector: #bezierIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 3 128 0 0 14 0 0 0 24 0 0 0 48 0 0 0 96 0 0 0 96 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">bringToFrontIconImage	"UIMaskEditor new openOnClass: self andSelector: #bringToFrontIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 128 126 0 0 191 126 0 0 187 126 0 0 179 126 0 0 160 62 0 0 128 30 0 0 160 14 0 0 179 6 0 0 187 70 0 0 191 102 0 0 191 102 0 0 191 102 0 0 191 78 0 0 191 62 0 0 128 126 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">bringToFrontIconMask	"UIMaskEditor new openOnClass: self andSelector: #bringToFrontIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 128 0 0 127 128 0 0 127 128 0 0 127 128 0 0 127 192 0 0 127 224 0 0 127 240 0 0 127 248 0 0 127 184 0 0 127 152 0 0 127 152 0 0 127 152 0 0 127 176 0 0 127 192 0 0 127 128 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">deleteIconImage	"UIMaskEditor new openOnClass: self andSelector: #deleteIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 190 0 0 255 94 0 0 254 238 0 0 253 246 0 0 251 250 0 0 247 242 0 0 239 234 0 0 223 218 0 0 191 182 0 0 127 110 0 0 62 222 0 0 93 190 0 0 107 126 0 0 182 254 0 0 213 254 0 0 227 254 0 0 247 254 0 0])</body><body package="HotDraw Framework">deleteIconMask	"UIMaskEditor new openOnClass: self andSelector: #deleteIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 224 0 0 1 240 0 0 3 248 0 0 7 252 0 0 15 252 0 0 31 252 0 0 63 252 0 0 127 248 0 0 255 240 0 0 255 224 0 0 255 192 0 0 255 128 0 0 127 0 0 0 62 0 0 0 28 0 0 0 8 0 0 0])</body><body package="HotDraw Framework">ellipseIconImage	"UIMaskEditor new openOnClass: self andSelector: #ellipseIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 248 126 0 0 231 158 0 0 223 238 0 0 223 238 0 0 191 246 0 0 191 246 0 0 223 238 0 0 223 238 0 0 231 158 0 0 248 126 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">ellipseIconMask	"UIMaskEditor new openOnClass: self andSelector: #ellipseIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 31 224 0 0 63 240 0 0 63 240 0 0 127 248 0 0 127 248 0 0 63 240 0 0 63 240 0 0 31 224 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">handIconImage	"UIMaskEditor new openOnClass: self andSelector: #handIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[254 127 0 0 229 143 0 0 217 183 0 0 217 181 0 0 237 178 0 0 237 182 0 0 151 246 0 0 103 254 0 0 119 253 0 0 191 253 0 0 223 253 0 0 239 251 0 0 239 251 0 0 247 247 0 0 251 247 0 0 248 7 0 0])</body><body package="HotDraw Framework">handIconMask	"UIMaskEditor new openOnClass: self andSelector: #handIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 27 240 0 0 63 248 0 0 63 250 0 0 31 255 0 0 31 255 0 0 111 255 0 0 255 255 0 0 255 254 0 0 127 254 0 0 63 254 0 0 31 252 0 0 31 252 0 0 15 248 0 0 7 248 0 0 7 248 0 0])</body><body package="HotDraw Framework">imageIconImage	"UIMaskEditor new openOnClass: self andSelector: #imageIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 143 226 0 0 191 250 0 0 191 250 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 191 250 0 0 191 250 0 0 143 226 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">imageIconMask	"UIMaskEditor new openOnClass: self andSelector: #imageIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 112 28 0 0 64 4 0 0 64 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 64 4 0 0 64 4 0 0 112 28 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">polylineIconImage	"UIMaskEditor new openOnClass: self andSelector: #polylineIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 126 0 0 254 62 0 0 252 158 0 0 249 206 0 0 243 230 0 0 231 206 0 0 207 158 0 0 159 62 0 0 199 126 0 0 241 254 0 0 252 126 0 0 255 30 0 0 255 198 0 0 255 206 0 0 255 158 0 0 255 62 0 0 255 254 0 0])</body><body package="HotDraw Framework">polylineIconMask	"UIMaskEditor new openOnClass: self andSelector: #polylineIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 128 0 0 1 192 0 0 3 96 0 0 6 48 0 0 12 24 0 0 24 48 0 0 48 96 0 0 96 192 0 0 56 128 0 0 14 0 0 0 3 128 0 0 0 224 0 0 0 56 0 0 0 48 0 0 0 96 0 0 0 192 0 0 0 0 0 0])</body><body package="HotDraw Framework">rectangleIconImage	"UIMaskEditor new openOnClass: self andSelector: #rectangleIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 128 2 0 0 191 250 0 0 191 250 0 0 191 250 0 0 191 250 0 0 191 250 0 0 191 250 0 0 191 250 0 0 191 250 0 0 128 2 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">rectangleIconMask	"UIMaskEditor new openOnClass: self andSelector: #rectangleIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">roundedRectangleIconImage	"UIMaskEditor new openOnClass: self andSelector: #roundedRectangleIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 240 30 0 0 207 230 0 0 223 246 0 0 191 250 0 0 191 250 0 0 191 250 0 0 191 250 0 0 223 246 0 0 207 230 0 0 240 30 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">roundedRectangleIconMask	"UIMaskEditor new openOnClass: self andSelector: #roundedRectangleIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 224 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 15 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">selectionIconImage	"UIMaskEditor new openOnClass: self andSelector: #selectionIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 239 254 0 0 231 254 0 0 235 254 0 0 237 254 0 0 238 254 0 0 239 126 0 0 239 190 0 0 239 222 0 0 239 14 0 0 237 126 0 0 233 190 0 0 230 190 0 0 238 222 0 0 255 94 0 0 255 62 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">selectionIconMask	"UIMaskEditor new openOnClass: self andSelector: #selectionIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 16 0 0 0 24 0 0 0 28 0 0 0 30 0 0 0 31 0 0 0 31 128 0 0 31 192 0 0 31 224 0 0 31 240 0 0 31 128 0 0 31 192 0 0 25 192 0 0 17 224 0 0 0 224 0 0 0 192 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">sendToBackIconImage	"UIMaskEditor new openOnClass: self andSelector: #sendToBackImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 128 126 0 0 191 126 0 0 184 62 0 0 184 14 0 0 184 6 0 0 191 98 0 0 191 112 0 0 191 120 0 0 191 104 0 0 191 72 0 0 191 0 0 0 191 2 0 0 191 78 0 0 191 110 0 0 128 126 0 0 255 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">sendToBackIconMask	"UIMaskEditor new openOnClass: self andSelector: #sendToBackIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 128 0 0 127 128 0 0 127 192 0 0 127 240 0 0 127 248 0 0 127 156 0 0 127 142 0 0 127 134 0 0 127 150 0 0 127 182 0 0 127 254 0 0 127 252 0 0 127 176 0 0 127 144 0 0 127 128 0 0 0 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">splineIconImage	"UIMaskEditor new openOnClass: self andSelector: #splineIconImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 193 254 0 0 128 254 0 0 28 118 0 0 62 102 0 0 62 78 0 0 62 30 0 0 28 62 0 0 128 254 0 0 193 254 0 0 243 254 0 0 231 254 0 0 207 254 0 0 159 254 0 0 255 254 0 0])</body><body package="HotDraw Framework">splineIconMask	"UIMaskEditor new openOnClass: self andSelector: #splineIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 62 0 0 0 127 0 0 0 227 136 0 0 193 152 0 0 193 176 0 0 193 224 0 0 227 192 0 0 127 0 0 0 62 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 96 0 0 0 0 0 0 0])</body><body package="HotDraw Framework">textFigureCreationImage	"UIMaskEditor new openOnClass: self andSelector: #textFigureCreationImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 192 3 0 0 192 3 0 0 222 123 0 0 254 127 0 0 254 127 0 0 254 127 0 0 254 127 0 0 254 127 0 0 254 127 0 0 254 127 0 0 254 123 0 0 252 49 0 0 255 238 0 0])</body><body package="HotDraw Framework">textFigureCreationMask	"UIMaskEditor new openOnClass: self andSelector: #textFigureCreationMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 63 252 0 0 63 252 0 0 33 132 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 132 0 0 3 206 0 0 0 17 0 0])</body><body package="HotDraw Framework">textMask	"UIMaskEditor new openOnClass: self andSelector: #textMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 63 252 0 0 63 252 0 0 33 132 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 3 192 0 0 0 0 0 0])</body></methods><methods><class-id>Refactory.HotDraw.DrawingEditor class</class-id> <category>interface specs</category><body package="HotDraw Framework">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Drawing Editor' 			#bounds: #(#{Graphics.Rectangle} 800 600 1355 1080 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 28 0 0 1 0 1 ) 					#flags: 11 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#component: #drawing ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 28 0 ) 					#flags: 0 					#component: #toolbar ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="HotDraw Framework">toolsHotDrawDrawingEditor	&lt;menuItem: 'Drawing Editor'		nameKey: nil		menu: #(#menuBar #tools #HotDraw)		position: 10.01&gt;	(#{Refactory.HotDraw.DrawingEditor} valueOrDo: [^self]) open</body><body package="HotDraw Framework">toolsHotDrawSubmenu	"Define a sub-menu for each of the HotDraw tools."	&lt;submenu: 'HotDraw'		nameKey: #HotDraw		menu: #(#menuBar #tools)		position: 29.01&gt;</body></methods><initialize><class-id>Refactory.HotDraw.Tool</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>